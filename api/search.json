[{"id":"36ed985afabbf28dbf33794d7b5319fd","title":"Typescript 教程","content":"TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。TypeScript 可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码 开源于 GitHub 上。英文：http://www.typescriptlang.org/中文：https://www.tslang.cn/\n\n\n安装 TypeScriptTypeScript 的命令行工具安装方法如下：\nnpm install -g typescript\n\n以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。在命令行上，运行 TypeScript 编译器：\ntsc hello.ts\n\n我们约定使用 TypeScript 编写的文件以 .ts 为后缀。\n基础类型介绍为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n布尔值布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：\nlet isDone: boolean &#x3D; false\n\n数字和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。\nlet decLiteral: number &#x3D; 6\nlet hexLiteral: number &#x3D; 0xf00d\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744\nlet notANumber: number &#x3D; NaN\nlet infinityNumber: number &#x3D; Infinity\n\n字符串JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（”）或单引号（’）表示字符串。\nlet myName: string &#x3D; &#39;Tom&#39;\nlet myAge: number &#x3D; 25\n\n&#x2F;&#x2F; 模板字符串\nlet sentence: string &#x3D; &#96;Hello, my name is $&#123;myName&#125;.\nI&#39;ll be $&#123;myAge + 1&#125; years old next month.&#96;\n\n其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。\n数组TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 [ ]，表示由此类型元素组成的一个数组：\nlet list: number[] &#x3D; [1, 2, 3]\n\n第二种方式是使用数组泛型，Array&lt;元素类型&gt;：\nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3]\n\n用接口表示数组：\ninterface NumberArray &#123;\n  [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5]\n\nNumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number。\n用 any 表示数组中允许出现任意类型：\nlet list: any[] &#x3D; [&#39;Xcat Liu&#39;, 25, &#123; website: &#39;http:&#x2F;&#x2F;xcatliu.com&#39; &#125;]\n\n元组 Tuple：元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。\n&#x2F;&#x2F; Declare a tuple type\nlet x: [string, number]\n&#x2F;&#x2F; Initialize it\nx &#x3D; [&#39;hello&#39;, 10] &#x2F;&#x2F; OK\n&#x2F;&#x2F; Initialize it incorrectly\nx &#x3D; [10, &#39;hello&#39;] &#x2F;&#x2F; Error\n\n枚举enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color &#123;Red, Green, Blue&#125;\nlet c: Color &#x3D; Color.Green;\n\n手动赋值:\nenum Days &#123;Sun &#x3D; 7, Mon &#x3D; 1, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 7); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Mon&quot;] &#x3D;&#x3D;&#x3D; 1); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Tue&quot;] &#x3D;&#x3D;&#x3D; 2); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6); &#x2F;&#x2F; true\n\nAny任意值（Any）用来表示允许赋值为任意类型\n在任意值上访问任何属性都是允许的：\nlet anyThing: any &#x3D; &#39;hello&#39;\nconsole.log(anyThing.myName)\nconsole.log(anyThing.myName.firstName)\n\n也允许调用任何方法：\nlet anyThing: any &#x3D; &#39;Tom&#39;\nanyThing.setName(&#39;Jerry&#39;)\nanyThing.setName(&#39;Jerry&#39;).sayHello()\nanyThing.myName.setFirstName(&#39;Cat&#39;)\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。\nVoid某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\nfunction warnUser(): void &#123;\n  alert(&#39;This is my warning message&#39;)\n&#125;\n\n声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：\nlet unusable: void &#x3D; undefined\n\nNull 和 UndefinedTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大：\nlet u: undefined &#x3D; undefined\nlet n: null &#x3D; null\n\nundefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined\n\n&#x2F;&#x2F; 这样也不会报错\nlet u: undefined\nlet num: number &#x3D; u\n\n&#x2F;&#x2F; 而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void\nlet num: number &#x3D; u\n\n&#x2F;&#x2F; index.ts(2,5): error TS2322: Type &#39;void&#39; is not assignable to type &#39;number&#39;.\n\n接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。\n使用接口（Interfaces）来定义对象的类型:\ninterface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  age: 25,\n&#125;\n\n赋值的时候，变量的形状必须和接口的形状保持一致。\n可选属性，有时我们希望不要完全匹配一个形状，那么可以用可选属性：\ninterface Person &#123;\n  name: string;\n  age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n&#125;\n\n可选属性的含义是该属性可以不存在,仍然不允许添加未定义的属性：\n任意属性, 有时候我们希望一个接口允许有任意的属性:\ninterface Person &#123;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  gender: &#39;male&#39;,\n&#125;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性：\ninterface Person &#123;\n  name: string;\n  age?: number;\n  [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  age: 25,\n  gender: &#39;male&#39;,\n&#125;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。另外，在报错信息中可以看出，此时 { name: ‘Tom’, age: 25, gender: ‘male’ } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。\n只读属性, 有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\ninterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.\n\n类传统的 JavaScript 程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n使用类的例子:\nclass Greeter &#123;\n  greeting: string\n  constructor(message: string) &#123;\n    this.greeting &#x3D; message\n  &#125;\n  greet() &#123;\n    return &#39;Hello, &#39; + this.greeting\n  &#125;\n&#125;\n\nlet greeter &#x3D; new Greeter(&#39;world&#39;)\n\n继承在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。类继承类：\nclass Animal &#123;\n  move(distanceInMeters: number &#x3D; 0) &#123;\n    console.log(&#96;Animal moved $&#123;distanceInMeters&#125;m.&#96;)\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  bark() &#123;\n    console.log(&#39;Woof! Woof!&#39;)\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog()\ndog.bark()\ndog.move(10)\ndog.bark()\n\n接口继承接口：\ninterface Alarm &#123;\n    alert();\n&#125;\n\ninterface LightableAlarm extends Alarm &#123;\n    lightOn();\n    lightOff();\n&#125;\n\n上例中，我们使用 extends 使 LightableAlarm 继承 Alarm。\n接口继承类：\nclass Point &#123;\n  x: number\n  y: number\n&#125;\n\ninterface Point3d extends Point &#123;\n  z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123; x: 1, y: 2, z: 3 &#125;\n\n公共，私有与受保护的修饰符默认为公共方法 public：\nclass Animal &#123;\n    public name: string;\n    public constructor(theName: string) &#123;\n    \tthis.name &#x3D; theName;\n    &#125;\n    public move(distanceInMeters: number) &#123;\n        console.log(&#96;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#96;);\n    &#125;\n&#125;\n\n静态方法 static:使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用。\nclass Animal &#123;\n  static isAnimal(a) &#123;\n    return a instanceof Animal\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;)\nAnimal.isAnimal(a) &#x2F;&#x2F; true\na.isAnimal(a) &#x2F;&#x2F; TypeError: a.isAnimal is not a function\n\n私有方法 private：当成员被标记成 private 时，它就不能在声明它的类的外部访问。\nclass Animal &#123;\n    private name: string;\n    constructor(theName: string) &#123;\n    \tthis.name &#x3D; theName;\n   \t&#125;\n&#125;\nnew Animal(&quot;Cat&quot;).name; &#x2F;&#x2F; 错误: &#39;name&#39; 是私有的\n\n存取器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。\nclass Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n  get name() &#123;\n    return &#39;Jack&#39;\n  &#125;\n  set name(value) &#123;\n    console.log(&#39;setter: &#39; + value)\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Kitty&#39;) &#x2F;&#x2F; setter: Kitty\na.name &#x3D; &#39;Tom&#39; &#x2F;&#x2F; setter: Tom\nconsole.log(a.name) &#x2F;&#x2F; Jack\n\n模块导出, 任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加 export 关键字来导出:\nexport interface StringValidator &#123;\n  isAcceptable(s: string): boolean;\n&#125;\n\n导入,模块的导入操作与导出一样简单。 可以使用以下 import 形式之一来导入其它模块中的导出内容。\nimport &#123; ZipCodeValidator &#125; from &#39;.&#x2F;ZipCodeValidator&#39;\n\nlet myValidator &#x3D; new ZipCodeValidator()\n\n可以对导入内容重命名\nimport &#123; ZipCodeValidator as ZCV &#125; from &#39;.&#x2F;ZipCodeValidator&#39;\nlet myValidator &#x3D; new ZCV()\n\n将整个模块导入到一个变量，并通过它来访问模块的导出部分\nimport * as validator from &#39;.&#x2F;ZipCodeValidator&#39;\nlet myValidator &#x3D; new validator.ZipCodeValidator()\n\n默认导出,每个模块都可以有一个 default 导出。 默认导出使用 default 关键字标记；并且一个模块只能够有一个 default 导出。 需要使用一种特殊的导入形式来导入 default 导出。\nexport default class ZipCodeValidator &#123;\n    static numberRegexp &#x3D; &#x2F;^[0-9]+$&#x2F;;\n    isAcceptable(s: string) &#123;\n        return s.length &#x3D;&#x3D;&#x3D; 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);\n    &#125;\n&#125;\n-------------------------------------------------------------------------\nimport validator from &quot;.&#x2F;ZipCodeValidator&quot;;\nlet myValidator &#x3D; new validator();\n\n类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。\n参考资料TypeScript 入门教程TypeScript 官方手册\n","slug":"Typescript教程","date":"2019-08-26T14:36:20.000Z","categories_index":"Typescript","tags_index":"Typescript","author_index":"Bobby's Blog"},{"id":"fba191276a9852d7cc27748cdc57a493","title":"React组件异步加载","content":"使用 react-loadable 快速完成异步组件的编写npm install react-loadable --save\n\n&#x2F;&#x2F; eq:\nimport Loadable from &#39;react-loadable&#39;;\nimport Loading from &#39;.&#x2F;my-loading-component&#39;;\nconst LoadableComponent &#x3D; Loadable(&#123;\n  loader: () &#x3D;&gt; import(&#39;.&#x2F;my-component&#39;),\n  loading: Loading,\n&#125;);\nexport default class App extends React.Component &#123;\n  render() &#123;\n    return &lt;LoadableComponent&#x2F;&gt;;\n  &#125;\n&#125;\n\n\n\n自定义异步组件 create syncComponent.jsimport React from &#39;react&#39;\n\nexport default (loadComponent) &#x3D;&gt;\n  class AsyncComponent extends React.Component &#123;\n    state &#x3D; &#123;\n      Component: null,\n    &#125;\n    async componentDidMount() &#123;\n      if (this.state.Component !&#x3D;&#x3D; null) return\n\n      try &#123;\n        const &#123; default: Component &#125; &#x3D; await loadComponent()\n        this.setState(&#123; Component &#125;)\n      &#125; catch (err) &#123;\n        console.error(&#39;Cannot load component in &lt;AsyncComponent &#x2F;&gt;&#39;)\n        throw err\n      &#125;\n    &#125;\n\n    render() &#123;\n      const &#123; Component &#125; &#x3D; this.state\n      return Component ? &lt;Component &#123;...this.props&#125; &#x2F;&gt; : null\n    &#125;\n  &#125;\n\n使用：\nimport asyncComponent from &#39;@&#x2F;components&#x2F;AsyncComponent&#39;\nconst _import_views &#x3D; (file) &#x3D;&gt; asyncComponent(() &#x3D;&gt; import(&#96;@&#x2F;views&#x2F;$&#123;file&#125;&#96;))\nconst Home &#x3D; _import_views(&#39;Home&#39;)\n","slug":"React组件异步加载","date":"2019-08-13T15:22:45.000Z","categories_index":"React","tags_index":"React","author_index":"Bobby's Blog"},{"id":"bbe4af776c0ccb3326bd13f893d1dc57","title":"vue.config.js 配置","content":"vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。\n\n\n配置参考\n&#x2F;&#x2F; vue.config.js\nconst path &#x3D; require(&#39;path&#39;)\nconst CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)\nconst productionGzipExtensions &#x3D; [&#39;js&#39;, &#39;css&#39;]\nconst isDevelopment &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;\nconst isProduction &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 部署应用包时的基本 URL\n  baseUrl: &#39;&#x2F;&#39;, &#x2F;&#x2F; Default: &#39;&#x2F;&#39;\n  &#x2F;&#x2F; 生成产环境构建文件的目录\n  outputDir: &#39;dist&#39;, &#x2F;&#x2F; Default: &#39;dist&#39;\n  &#x2F;&#x2F; 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录\n  assetsDir: &#39;assets&#39;, &#x2F;&#x2F; Default: &#39;&#39;\n  &#x2F;&#x2F; 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径\n  indexPath: &#39;index.html&#39;,\n  &#x2F;&#x2F; 成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存\n  filenameHashing: true, &#x2F;&#x2F; Default: true\n  &#x2F;&#x2F; 多页面配置\n  pages: undefined,\n  &#x2F;&#x2F; 是否在开发环境下通过 eslint-loader 在每次保存时 lint 代码\n  lintOnSave: true, &#x2F;&#x2F; Default: true\n  &#x2F;&#x2F; 是否使用包含运行时编译器的 Vue 构建版本\n  runtimeCompiler: true, &#x2F;&#x2F; Default: false\n  &#x2F;&#x2F; 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建\n  productionSourceMap: false, &#x2F;&#x2F; Default: true\n  &#x2F;&#x2F; 设置生成的 HTML 中 &lt;link rel&#x3D;&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签的 crossorigin 属性\n  crossorigin: undefined,\n  &#x2F;&#x2F; 在生成的 HTML 中的 &lt;link rel&#x3D;&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签上启用 Subresource Integrity (SRI)。如果你构建后的文件是部署在 CDN 上的，启用该选项可以提供额外的安全性\n  integrity: false, &#x2F;&#x2F; Default: false\n  &#x2F;&#x2F; 通过 webpack-merge 合并到最终的配置中\n  configureWebpack: (config) &#x3D;&gt; &#123;\n    if (isDevelopment) &#123;\n      &#x2F;&#x2F; 开发环境配置\n      config.devtool &#x3D; &#39;cheap-module-eval-source-map&#39;\n    &#125; else &#123;\n      &#x2F;&#x2F; 生产构建配置\n\n      &#x2F;&#x2F; 忽略打包配置\n      config.externals &#x3D; cdn.externals\n\n      &#x2F;&#x2F; 开启gzip压缩\n      config.plugins.push(\n        new CompressionWebpackPlugin(&#123;\n          filename: (info) &#x3D;&gt; &#123;\n            return &#96;$&#123;info.path&#125;.gz$&#123;info.query&#125;&#96;\n          &#125;,\n          algorithm: &#39;gzip&#39;,\n          threshold: 10240, &#x2F;&#x2F; 只有大小大于该值的资源会被处理 10240\n          test: new RegExp(&#39;\\\\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;),\n          minRatio: 0.8, &#x2F;&#x2F; 只有压缩率小于这个值的资源才会被处理\n          deleteOriginalAssets: false, &#x2F;&#x2F; 删除原文件\n        &#125;)\n      )\n\n      &#x2F;&#x2F; 公共代码抽离\n      config.optimization &#x3D; &#123;\n        splitChunks: &#123;\n          cacheGroups: &#123;\n            vendor: &#123;\n              chunks: &#39;all&#39;,\n              test: &#x2F;node_modules&#x2F;,\n              name: &#39;vendor&#39;,\n              minChunks: 2,\n              priority: 100,\n            &#125;,\n          &#125;,\n        &#125;,\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 开发生产共同配置\n    Object.assign(config, &#123;\n      resolve: &#123;\n        alias: &#123;\n          &#39;@&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#39;),\n          &#39;@c&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;components&#39;),\n          vue$: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;,\n        &#125;,\n      &#125;,\n    &#125;)\n  &#125;,\n  &#x2F;&#x2F; 允许对内部的 webpack 配置进行更细粒度的修改\n  chainWebpack: (config) &#x3D;&gt; &#123;\n    if (isDevelopment) &#123;\n      &#x2F;&#x2F; 开发环境配置\n    &#125; else &#123;\n      &#x2F;&#x2F; 生产构建配置\n    &#125;\n  &#125;,\n  css: &#123;\n    &#x2F;&#x2F; 启用 CSS modules\n    modules: true,\n    &#x2F;&#x2F; 是否将组件中的 CSS 提取至一个独立的 CSS 文件中\n    extract: true, &#x2F;&#x2F; Default: 生产环境下是 true，开发环境下是 false\n    &#x2F;&#x2F; 是否为 CSS 开启 source map\n    sourceMap: false, &#x2F;&#x2F; 设置为 true 之后可能会影响构建的性能\n    loaderOptions: &#123;\n      &#x2F;&#x2F; css预设器配置项\n      css: &#123;\n        localIdentName: &#39;[name]-[hash]&#39;,\n        camelCase: &#39;only&#39;,\n      &#125;,\n      stylus: &#123;&#125;,\n    &#125;,\n  &#125;,\n  parallel: require(&#39;os&#39;).cpus().length &gt; 1, &#x2F;&#x2F; 是否为 Babel 或 TypeScript 使用 thread-loader, 仅作用于生产构建\n  pluginOptions: &#123;&#125;, &#x2F;&#x2F; 第三方插件配置\n  pwa: &#123;&#125;, &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-cli&#x2F;tree&#x2F;dev&#x2F;packages&#x2F;%40vue&#x2F;cli-plugin-pwa\n  devServer: &#123;\n    open: true,\n    host: &#39;0.0.0.0&#39;, &#x2F;&#x2F; localhost\n    port: 8080,\n    https: false,\n    hotOnly: false,\n    proxy: &#123;\n      &#39;&#x2F;api&#39;: &#123;\n        target: &#39;&lt;url&gt;&#39;,\n        ws: true,\n        changOrigin: true,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;\n\n配置 aliasconst path &#x3D; require(&#39;path&#39;)\n\nfunction resolve(dir) &#123;\n  return path.join(__dirname, &#39;.&#x2F;&#39;, dir)\n&#125;\n\nchainWebpack: (config) &#x3D;&gt; &#123;\n  config.resolve.alias.set(&#39;assets&#39;, resolve(&#39;src&#x2F;assets&#39;)).set(&#39;common&#39;, resolve(&#39;src&#x2F;common&#39;)).set(&#39;components&#39;, resolve(&#39;src&#x2F;components&#39;))\n&#125;\n\n配置 svg&#x2F;&#x2F; npm install svg-sprite-loader\n\nchainWebpack: (config) &#x3D;&gt; &#123;\n  config.module.rule(&#39;svg&#39;).exclude.add(resolve(&#39;src&#x2F;icons&#39;)).end()\n\n  config.module\n    .rule(&#39;icons&#39;)\n    .test(&#x2F;\\.svg$&#x2F;)\n    .include.add(resolve(&#39;src&#x2F;icons&#39;))\n    .end()\n    .use(&#39;svg-sprite-loader&#39;)\n    .loader(&#39;svg-sprite-loader&#39;)\n    .options(&#123;\n      symbolId: &#39;icon-[name]&#39;,\n    &#125;)\n&#125;\n\n配置 Gizp&#x2F;&#x2F; npm install compression-webpack-plugin -D\nconst productionGzipExtensions &#x3D; [&#39;js&#39;, &#39;css&#39;]\n\nconfigureWebpack: &#123;\n    plugins: [\n      new CompressionWebpackPlugin(&#123;\n        filename: &#39;[path].gz[query]&#39;,\n        algorithm: &#39;gzip&#39;,\n        test: new RegExp(&#39;\\\\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;),\n        threshold: 10240,\n        minRatio: 0.8,\n        deleteOriginalAssets: false\n      &#125;)\n    ]\n  &#125;,\n","slug":"Vue.config.js配置","date":"2019-07-15T12:19:10.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"Bobby's Blog"},{"id":"bbd0c31743d20bd19a12a5038f16f175","title":"Create-react-app脚手架配置less、scss和css modules","content":"使用 create-react-app 创建的项目默认不支持 less scss，以下增加 less scss 配置的步骤\n\n暴露配置文件\n\nnpm run eject\n\n\n在 node_modules/react-scripts/config 下找到 webpack.config.dev.js 和 webpack.config-prod.js 配置文件进行修改\n\n安装 less-loader 和 less\nnpm install less-loader less --save-dev\n\n修改 webpack.config.dev.js 和 webpack.config-prod.js 配置文件\n\n\n&#123;\n  test: &#x2F;\\.(css|less)$&#x2F;,\n  use: [\n    require.resolve(&#39;style-loader&#39;),\n    &#123;\n      loader: require.resolve(&#39;css-loader&#39;),\n      options: &#123;\n        importLoaders: 1,\n      &#125;,\n    &#125;,\n    &#123;\n      loader: require.resolve(&#39;postcss-loader&#39;),\n      options: &#123;\n        &#x2F;&#x2F; Necessary for external CSS imports to work\n        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;facebookincubator&#x2F;create-react-app&#x2F;issues&#x2F;2677\n        ident: &#39;postcss&#39;,\n        plugins: () &#x3D;&gt; [\n          require(&#39;postcss-flexbugs-fixes&#39;),\n          autoprefixer(&#123;\n            browsers: [\n              &#39;&gt;1%&#39;,\n              &#39;last 4 versions&#39;,\n              &#39;Firefox ESR&#39;,\n              &#39;not ie &lt; 9&#39;, &#x2F;&#x2F; React doesn&#39;t support IE8 anyway\n            ],\n            flexbox: &#39;no-2009&#39;,\n          &#125;),\n        ],\n      &#125;,\n    &#125;,\n    &#123;\n      loader: require.resolve(&#39;less-loader&#39;) &#x2F;&#x2F; compiles Less to CSS\n    &#125;\n  ],\n&#125;,\n\n使用 CSS modules\n&#123;\n    loader: require.resolve(&#39;css-loader&#39;),\n    options: &#123;\n        importLoaders: 1,\n    &#125;,\n&#125;,\n\n&#123;\n  loader: require.resolve(&#39;css-loader&#39;),\n  options: &#123;\n    importLoaders: 1,\n    + modules: true,\n    + localIdentName: &quot;[name]__[local]___[hash:base64:5]&quot;\n  &#125;,\n&#125;\n\n安装 scss-loader 和 scss\nnpm install sass-loader node-sass --save-dev\n\n修改 webpack.config.dev.js 和 webpack.config-prod.js 配置文件\n&#123;\n    loader: require.resolve(&#39;file-loader&#39;),\n    &#x2F;&#x2F; Exclude &#96;js&#96; files to keep &quot;css&quot; loader working as it injects\n    &#x2F;&#x2F; it&#39;s runtime that would otherwise processed through &quot;file&quot; loader.\n    &#x2F;&#x2F; Also exclude &#96;html&#96; and &#96;json&#96; extensions so they get processed\n    &#x2F;&#x2F; by webpacks internal loaders.\n    exclude: [&#x2F;\\.js$&#x2F;, &#x2F;\\.html$&#x2F;, &#x2F;\\.json$&#x2F;, &#x2F;\\.scss$&#x2F;],\n    options: &#123;\n         name: &#39;static&#x2F;media&#x2F;[name].[hash:8].[ext]&#39;,\n    &#125;,\n&#125;,\n&#123;\n    test: &#x2F;\\.scss$&#x2F;,\n    loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;],\n&#125;\n\n使用 CSS modules\n &#123;\n  test: &#x2F;\\.scss$&#x2F;,\n  use: [\n    &#123; loader: &quot;style-loader&quot; &#125;,\n    &#123;\n      loader: &quot;css-loader&quot;,\n      options: &#123;\n        importLoaders: 1,\n        modules: true,\n        localIdentName: &quot;[name]___[hash:base64:5]&quot;\n      &#125;\n    &#125;,\n    &#123; loader: &quot;sass-loader&quot; &#125;\n  ]\n  &#x2F;&#x2F; loaders: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;],\n&#125;\n","slug":"Create-react-app脚手架配置less、scss和css modules","date":"2019-06-10T14:58:22.000Z","categories_index":"React","tags_index":"React","author_index":"Bobby's Blog"},{"id":"bcecceec14c0a7497b90500561edea6c","title":"Gulp 配置教程","content":"Gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。Gulp 基于 Node.js 的前端构建工具，通过 Gulp 的插件可以实现前端代码的编译、检查、合并、压缩、格式化、浏览器自动刷新，还有许多强大的插件可以在这里查找，也可以在 npm 里搜索查找需要的插件，比起 Grunt 不仅配置简单而且更容易阅读和维护。英文：https://gulpjs.com/中文：https://www.gulpjs.com.cn/docs/api/\n\n\n全局安装 gulp:$ npm install --global gulp\n\n作为项目的开发依赖（devDependencies）安装：$ npm install --save-dev gulp\n\n在项目根目录下创建一个名为 gulpfile.js 的文件:&#x2F;&#x2F; 引入 gulp\nvar gulp &#x3D; require(&#39;gulp&#39;)\n\n&#x2F;&#x2F; 引入组件\nvar jslint &#x3D; require(&#39;gulp-jslint&#39;),\n  sass &#x3D; require(&#39;gulp-ruby-sass&#39;),\n  less &#x3D; require(&#39;gulp-less&#39;),\n  changed &#x3D; require(&#39;gulp-changed&#39;),\n  htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;),\n  minifyHTML &#x3D; require(&#39;gulp-minify-html&#39;),\n  minifycss &#x3D; require(&#39;gulp-minify-css&#39;),\n  autoprefixer &#x3D; require(&#39;gulp-autoprefixer&#39;),\n  concat &#x3D; require(&#39;gulp-concat&#39;),\n  uglify &#x3D; require(&#39;gulp-uglify&#39;),\n  base64 &#x3D; require(&#39;gulp-base64&#39;),\n  imagemin &#x3D; require(&#39;gulp-imagemin&#39;),\n  pngquant &#x3D; require(&#39;imagemin-pngquant&#39;),\n  clean &#x3D; require(&#39;gulp-clean&#39;),\n  rename &#x3D; require(&#39;gulp-rename&#39;),\n  notify &#x3D; require(&#39;gulp-notify&#39;),\n  livereload &#x3D; require(&#39;gulp-livereload&#39;),\n  cache &#x3D; require(&#39;gulp-cache&#39;),\n  del &#x3D; require(&#39;del&#39;),\n  rev &#x3D; require(&#39;gulp-rev&#39;),\n  revCollector &#x3D; require(&#39;gulp-rev-collector&#39;),\n  sourcemaps &#x3D; require(&#39;gulp-sourcemaps&#39;),\n  browserSync &#x3D; require(&#39;browser-sync&#39;).create()\n\nfunction errLog(error) &#123;\n  console.error.bind(console)\n  this.emit(&#39;end&#39;)\n&#125;\n\n&#x2F;&#x2F; jslint\ngulp.task(&#39;jslint&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;js&#x2F;**&#x2F;*.js&#39;)\n    .pipe(jslint())\n    .pipe(jslint.reporter(&#39;default&#39;))\n    .pipe(notify(&#123; message: &#39;Jslint task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; autoprefixer\ngulp.task(&#39;autoprefixer&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;css&#x2F;**&#x2F;*.css&#39;)\n    .pipe(\n      autoprefixer(&#123;\n        browsers: [&#39;last 2 versions&#39;, &#39;Android &gt;&#x3D; 4.0&#39;],\n        cascade: true,\n        remove: true,\n      &#125;)\n    )\n    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;))\n    .pipe(notify(&#123; message: &#39;Autoprefixer task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; html\ngulp.task(&#39;html&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;**&#x2F;*.html&#39;)\n    .pipe(htmlmin(&#123; collapseWhitespace: true &#125;))\n    .pipe(gulp.dest(&#39;dist&#39;))\n    .pipe(notify(&#123; message: &#39;HTML task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; js\ngulp.task(&#39;js&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;js&#x2F;**&#x2F;*.js&#39;)\n    .pipe(sourcemaps.init())\n    .pipe(uglify())\n    .pipe(rev())\n    .pipe(gulp.dest(&#39;dist&#x2F;js&#39;))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest(&#39;rev&#x2F;js&#39;))\n    .pipe(notify(&#123; message: &#39;Js task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; css\ngulp.task(&#39;css&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;css&#x2F;*.css&#39;)\n    .pipe(\n      autoprefixer(&#123;\n        browsers: [&#39;last 2 versions&#39;, &#39;Android &gt;&#x3D; 4.0&#39;],\n        cascade: true,\n        remove: true,\n      &#125;)\n    )\n    .pipe(base64())\n    .pipe(minifycss())\n    .pipe(rev())\n    .on(&#39;error&#39;, errLog)\n    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest(&#39;rev&#x2F;css&#39;))\n    .pipe(notify(&#123; message: &#39;Styles task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; rev\ngulp.task(&#39;rev&#39;, function () &#123;\n  return gulp\n    .src([&#39;rev&#x2F;**&#x2F;*.json&#39;, &#39;src&#x2F;**&#x2F;*.html&#39;])\n    .pipe(\n      revCollector(&#123;\n        replaceReved: true,\n        dirReplacements: &#123;\n          css: &#39;css&#39;,\n          js: &#39;js&#39;,\n          &#39;cdn&#x2F;&#39;: function (manifest_value) &#123;\n            return &#39;&#x2F;&#x2F;cdn&#39; + (Math.floor(Math.random() * 9) + 1) + &#39;.&#39; + &#39;exsample.dot&#39; + &#39;&#x2F;images&#x2F;&#39; + manifest_value\n          &#125;,\n        &#125;,\n      &#125;)\n    )\n    .pipe(\n      minifyHTML(&#123;\n        empty: true,\n        pare: true,\n      &#125;)\n    )\n    .pipe(gulp.dest(&#39;dist&#39;))\n    .pipe(notify(&#123; message: &#39;Rev task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; sass\ngulp.task(&#39;sass&#39;, () &#x3D;&gt;\n  sass(&#39;src&#x2F;scss&#x2F;*.scss&#39;, &#123; style: &#39;compressed&#39; &#125;)\n    .pipe(\n      autoprefixer(&#123;\n        browsers: [&#39;last 2 versions&#39;, &#39;Android &gt;&#x3D; 4.0&#39;],\n        cascade: true,\n        remove: true,\n      &#125;)\n    )\n    .pipe(base64())\n    .pipe(minifycss())\n    .on(&#39;error&#39;, errLog)\n    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;))\n    .pipe(notify(&#123; message: &#39;Sass task complete&#39; &#125;))\n)\n\n&#x2F;&#x2F; less\ngulp.task(&#39;less&#39;, function () &#123;\n  return gulp\n    .src(&#39;.&#x2F;src&#x2F;less&#x2F;**&#x2F;*.less&#39;)\n    .pipe(less())\n    .pipe(\n      autoprefixer(&#123;\n        browsers: [&#39;last 2 versions&#39;, &#39;Android &gt;&#x3D; 4.0&#39;],\n        cascade: true,\n        remove: true,\n      &#125;)\n    )\n    .pipe(base64())\n    .pipe(minifycss())\n    .on(&#39;error&#39;, errLog)\n    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;))\n    .pipe(notify(&#123; message: &#39;Less task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; images\ngulp.task(&#39;images&#39;, function () &#123;\n  gulp\n    .src(&#39;src&#x2F;images&#x2F;**&#x2F;*&#39;)\n    .pipe(\n      cache(\n        imagemin(&#123;\n          optimizationLevel: 5,\n          progressive: true,\n          interlaced: true,\n          svgoPlugins: [&#123; removeViewBox: false &#125;],\n          use: [pngquant()],\n        &#125;)\n      )\n    )\n    .pipe(gulp.dest(&#39;dist&#x2F;images&#39;))\n    .pipe(notify(&#123; message: &#39;Images task complete&#39; &#125;))\n&#125;)\n\n&#x2F;&#x2F; clean\ngulp.task(&#39;clean&#39;, function () &#123;\n  del([&#39;.&#x2F;dist&#39;, &#39;.&#x2F;rev&#39;])\n&#125;)\n\n&#x2F;&#x2F; default\ngulp.task(&#39;default&#39;, function () &#123;\n  gulp.start(&#39;html&#39;, &#39;css&#39;, &#39;sass&#39;, &#39;less&#39;, &#39;js&#39;, &#39;images&#39;)\n&#125;)\n\n&#x2F;&#x2F; watch\ngulp.task(&#39;watch&#39;, function () &#123;\n  &#x2F;&#x2F; browserSync\n  browserSync.init(&#123;\n    server: &#123;\n      baseDir: &#39;.&#x2F;dist&#39;,\n      index: &#39;index.html&#39;,\n    &#125;,\n    open: &#39;external&#39;,\n    injectChanges: true,\n  &#125;)\n\n  gulp.watch(&#39;src&#x2F;css&#x2F;**&#x2F;*.css&#39;, [&#39;css&#39;])\n  gulp.watch(&#39;src&#x2F;scss&#x2F;**&#x2F;*.scss&#39;, [&#39;sass&#39;])\n  gulp.watch(&#39;src&#x2F;less&#x2F;**&#x2F;*.less&#39;, [&#39;less&#39;])\n  gulp.watch(&#39;src&#x2F;js&#x2F;**&#x2F;*.js&#39;, [&#39;js&#39;])\n  gulp.watch(&#39;src&#x2F;images&#x2F;**&#x2F;*&#39;, [&#39;images&#39;])\n  gulp.watch(&#39;src&#x2F;**&#x2F;*.html&#39;, [&#39;rev&#39;])\n  gulp.watch([&#39;dist&#x2F;**&#39;]).on(&#39;change&#39;, browserSync.reload)\n&#125;)\n\n运行 gulp:npm install   &#x2F;&#x2F;安装插件\n\n&#x2F;&#x2F;gulp 命令\ngulp-clean    &#x2F;&#x2F;清除\ngulp-watch    &#x2F;&#x2F;监听文件\ngulp-default  &#x2F;&#x2F;压缩\n\ngulp 常用插件var gulp &#x3D; require(&#39;gulp&#39;); &#x2F;&#x2F;gulp\nvar jshint &#x3D; require(&#39;gulp-jshint&#39;); &#x2F;&#x2F; 引入检测js文件模块\nvar uglify &#x3D; require(&#39;gulp-uglify&#39;); &#x2F;&#x2F; 引入js压缩模块\nvar concat &#x3D; require(&#39;gulp-concat&#39;); &#x2F;&#x2F; 引入合并文件模块\nvar sourcemaps &#x3D; require(&#39;gulp-sourcemaps&#39;); &#x2F;&#x2F; 引入sourcemaps\nvar htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;); &#x2F;&#x2F; 引入html压缩模块\nvar cleanCSS &#x3D; require(&#39;gulp-clean-css&#39;); &#x2F;&#x2F; 引入压缩css的模块\nvar imagemin &#x3D; require(&#39;gulp-imagemin&#39;); &#x2F;&#x2F; 引入压缩图片插件\nvar postcss &#x3D; require(&#39;gulp-postcss&#39;); &#x2F;&#x2F;JavaScript 代码来转换CSS 中的样式\nvar autoprefixer &#x3D; require(&#39;autoprefixer&#39;); &#x2F;&#x2F;自动加上浏览器前缀\nvar postcsswritesvg &#x3D; require(&#39;postcss-write-svg&#39;); &#x2F;&#x2F; 解决1px方案\nvar browserSync &#x3D; require(&#39;browser-sync&#39;); &#x2F;&#x2F;默认浏览器打开\nvar cache &#x3D; require(&#39;gulp-cache&#39;); &#x2F;&#x2F;缓存\nvar opn &#x3D; require(&#39;opn&#39;); &#x2F;&#x2F;静态服务器\nvar autoprefixer &#x3D; require(&#39;gulp-autoprefixer&#39;); &#x2F;&#x2F;根据设置浏览器版本自动处理浏览器前缀\nvar concat &#x3D; require(&#39;gulp-concat&#39;); &#x2F;&#x2F;合并javascript文件，减少网络请求\nvar base64 &#x3D; require(&#39;gulp-base64&#39;); &#x2F;&#x2F;图片转换成Base64编码\nvar sass &#x3D; require(&#39;gulp-ruby-sass&#39;); &#x2F;&#x2F;sass\nvar less &#x3D; require(&#39;gulp-less&#39;); &#x2F;&#x2F;less\nvar rename &#x3D; require(&#39;gulp-rename&#39;); &#x2F;&#x2F;重命名\nvar notify &#x3D; require(&#39;gulp-notify&#39;); &#x2F;&#x2F;提示\nvar livereload &#x3D; require(&#39;gulp-livereload&#39;); &#x2F;&#x2F;监听文件发生变化时,浏览器自动刷新页面\nvar rev &#x3D; require(&#39;gulp-rev&#39;); 根据静态资源内容，生成md5签名，打包出来的文件名会加上md5签名，同时生成一个json用来保存文件名路径对应关系\nvar revCollector &#x3D; require(&#39;gulp-rev-collector&#39;);\nvar changed &#x3D; require(&#39;gulp-changed&#39;); &#x2F;&#x2F;用来过滤未被修改过的文件，只有修改后的文件才能通过管道。这样做的好处时，只处理修改后的文件，减少后续程序的执行时间。\nvar clean &#x3D; require(&#39;gulp-clean&#39;); &#x2F;&#x2F;删除文件及文件夹，在执行打包的时候，一般都需要先清理目标文件夹，以保证每次打包时，都是最新的文件\n","slug":"Gulp配置教程","date":"2019-05-25T14:28:46.000Z","categories_index":"Gulp","tags_index":"Gulp","author_index":"Bobby's Blog"},{"id":"3ec09ca678cbb84e2a1f5d3e2f3e164f","title":"移动端 web 开发技巧","content":"在开发移动端的 Web 项目时踩了很多的坑，感觉有必要把它们记录下来，分享给即将踏入移动端 Web 开发大门的新人们。\n\n\nMETA 相关1. 添加到主屏后的标题（IOS）&lt;meta name&#x3D;&quot;apple-mobile-web-app-title&quot; content&#x3D;&quot;标题&quot;&gt;\n\n2. 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）\n&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;\n&lt;meta name&#x3D;&quot;apple-touch-fullscreen&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;\n\n3. 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个 meta 标签来禁止它：\n&lt;meta http-equiv&#x3D;&#39;Cache-Control&#39; content&#x3D;&#39;no-siteapp&#39; &#x2F;&gt;\n\n4. 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在”apple-mobile-web-app-capable” content=”yes”时生效\n&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;\n&lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black-translucent&quot; &#x2F;&gt;\n\ncontent 参数：\ndefault ：状态栏背景是白色。\nblack ：状态栏背景是黑色。\nblack-translucent ：状态栏背景是半透明。如果设置为 default 或 black,网页内容从状态栏底部开始。\n如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。\n\n5.移动端手机号码识别（IOS）在 iOS Safari（其他浏览器和 Android 均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：\n\n7 位数字，形如：1234567\n带括号及加号的数字，形如：(+86)123456789\n双连接线的数字，形如：00-00-00111\n11 位数字，形如：13800138000\n\n可能还有其他类型的数字也会被识别。我们可以通过如下的 meta 来关闭电话号码的自动识别：\n&lt;meta name&#x3D;&#39;format-detection&#39; content&#x3D;&#39;telephone&#x3D;no&#39; &#x2F;&gt;\n\n6. 开启电话功能/开启短信功能&lt;a href&#x3D;&quot;tel:123456&quot;&gt;123456&lt;&#x2F;a&gt; &#x2F;&#x2F;开启电话功能\n&lt;a href&#x3D;&quot;sms:123456&quot;&gt;123456&lt;&#x2F;a&gt; &#x2F;&#x2F;开启短信功能\n\n7. 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的 meta 来管别邮箱的自动识别：\n&lt;meta name&#x3D;&#39;format-detection&#39; content&#x3D;&#39;email&#x3D;no&#39; &#x2F;&gt;\n\n同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：\n&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;&#x2F;a&gt;  &#x2F;&#x2F;开启邮箱发送功能\n\n8. 优先使用最新版本 IE 和 Chrome&lt;meta http-equiv&#x3D;&#39;X-UA-Compatible&#39; content&#x3D;&#39;IE&#x3D;edge,chrome&#x3D;1&#39; &#x2F;&gt;\n\n9. 控制 http 请求中的 referer&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;never&quot;&gt;\n\nreferer 的 content 参数可以设置为以下几种类型的值：\n\nnever\nalways\norigin\ndefault\n\n如果在文档中插入 meta 标签，并且 name 属性的值为 referer，浏览器客户端将按照如下步骤处理这个标签：\n如果 meta 标签中没有 content 属性，则终止下面所有操作\n将 content 的值复制给 referrer-policy ，并转换为小写\n检查 content 的值是否为上面 list 中的一个，如果不是，则将值置为 default\n\n上述步骤之后，浏览器后续发起 http 请求的时候，会按照 content 的值，做出如下反应(下面 referer-policy 的值即 meta 标签中 content 的值)：\n如果 referer-policy 的值为never：删除 http head 中的 referer；\n如果 referer-policy 的值为default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；\n如果 referer-policy 的值为 origin：只发送 origin 部分；\n如果 referer-policy 的值为 always：不改变http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。\n\n10. 移动端 web 开发 meta 常见设置&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n    &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;!-- 优先使用最新版本 IE 和 Chrome --&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;\n    &lt;!--忽略电话号码和email识别--&gt;\n    &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot;&#x2F;&gt;\n    &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot;&#x2F;&gt;\n    &lt;!--当网站添加到主屏幕快速启动方式，将网站添加到主屏幕快速启动方式--&gt;\n    &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot;&#x2F;&gt;\n    &lt;!--隐藏ios上的浏览器地址栏--&gt;\n    &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot;&#x2F;&gt;\n    &lt;!-- UC默认竖屏 ，UC强制全屏 --&gt;\n    &lt;meta name&#x3D;&quot;full-screen&quot; content&#x3D;&quot;yes&quot;&gt;\n    &lt;meta name&#x3D;&quot;browsermode&quot; content&#x3D;&quot;application&quot;&gt;\n    &lt;!-- QQ强制竖屏 QQ强制全屏 --&gt;\n    &lt;meta name&#x3D;&quot;x5-orientation&quot; content&#x3D;&quot;portrait&quot;&gt;\n    &lt;meta name&#x3D;&quot;x5-fullscreen&quot; content&#x3D;&quot;true&quot;&gt;\n    &lt;meta name&#x3D;&quot;x5-page-mode&quot; content&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 移动端viewport设置 --&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0, minimum-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;no&quot;&gt;\n    &lt;!-- 作者，关键字，描述 --&gt;\n    &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;author name&quot;&#x2F;&gt;\n    &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;keywords&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;description&quot;&#x2F;&gt;\n    &lt;!-- 添加网站上浏览器标签头图标  --&gt;\n    &lt;link rel&#x3D;&quot;shortcut icon&quot; href&#x3D;&quot;images&#x2F;favicon.ico&quot;&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\ncss 相关1. ios 系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios 用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color 的 alpha 值为 0，也就是属性值的最后一位设置为 0 就可以去除半透明灰色遮罩\na,button,input,textarea&#123;\n    -webkit-tap-highlight-color: rgba(0,0,0,0)\n&#125;\n\n2. 部分 android 系统中元素被点击时产生的边框怎么去掉android 用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color 的 alpha 值为 0 去除部分机器自带的效果\na,button,input,textarea&#123;\n    -webkit-tap-highlight-color: rgba(0,0,0,0)\n    -webkit-user-modify:read-write-plaintext-only;\n&#125;\n\n-webkit-user-modify 有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米 2对于按钮类还有个办法，不使用 a 或者 input 标签，直接用 div 标签\n3. winphone 系统 a、input 标签被点击时产生的半透明灰色背景怎么去掉&lt;meta name&#x3D;&quot;msapplication-tap-highlight&quot; content&#x3D;&quot;no&quot;&gt;\n\n4. webkit 表单元素的默认外观怎么重置.css&#123;-webkit-appearance:none;&#125;\n\n5. webkit 表单输入框 placeholder 的颜色值能改变么input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;\ninput:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125;\n\n6. webkit 表单输入框 placeholder 的文字能换行么ios 可以，android 不行~\n7. 关闭 iOS 键盘首字母自动大写在 iOS 中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：\n&lt;input type&#x3D;&#39;text&#39; autocapitalize&#x3D;&#39;off&#39; &#x2F;&gt;\n\n8. 关闭 iOS 输入自动修正和英文输入默认自动首字母大写那样，IOS 还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过 input 标签属性来关闭掉：\n&lt;input type&#x3D;&#39;text&#39; autocorrect&#x3D;&#39;off&#39; &#x2F;&gt;\n\n9. 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：\nhtml &#123;\n    -webkit-text-size-adjust: 100%;\n&#125;\n\n需要注意的是，PC 端的该属性已经被移除，该属性在移动端要生效，必须设置 ‘meta viewport’。\n10. 移动端如何清除输入框内阴影在 iOS 上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：\ninput,textarea &#123;\n    border: 0; &#x2F;* 方法1 *&#x2F;\n    -webkit-appearance: none; &#x2F;* 方法2 *&#x2F;\n&#125;\n\n11. 移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在 css 中禁掉：\n.user-select-none &#123;\n    -webkit-user-select: none;  &#x2F;* Chrome all &#x2F; Safari all *&#x2F;\n    -moz-user-select: none;     &#x2F;* Firefox all （移动端不需要） *&#x2F;\n    -ms-user-select: none;      &#x2F;* IE 10+ *&#x2F;\n&#125;\n\n12. 移动端取消 touch 高亮效果在做移动端页面时，会发现所有 a 标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过 css 以下方法来进行全局的禁止：\nhtml &#123;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n&#125;\n\n但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的 a 标签换成其它标签，可以解决这个问题。\n13. 如何禁止保存或拷贝图像（IOS）通常当你在手机或者 pad 上长按图像 img ，会弹出选项 存储图像 或者 拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：\nimg &#123; -webkit-touch-callout: none; &#125;\n\n14. 模拟按钮 hover 效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用 css 的 hover 并不能满足我们的需求，还好有个激活 css 的 active 效果，例子代码如下:\na &#123; color: #fff; &#125;\na:active &#123; color: #000; &#125;\n\n兼容性 ios5+、部分 android 4+、winphone 8要做到全兼容的办法，可通过监听 touchstart 和 touchend 来控制按钮的类名\ndocument.addEventListener(&#39;touchstart&#39;, function () &#123;&#125;, true)\ndocument.addEventListener(&#39;touchend&#39;, function () &#123;&#125;, true)\n\n15. 手机拍照和上传图片&lt;!-- 选择照片 --&gt;\n&lt;input type&#x3D;file accept&#x3D;&quot;image&#x2F;*&quot;&gt;\n&lt;!-- 选择视频 --&gt;\n&lt;input type&#x3D;file accept&#x3D;&quot;video&#x2F;*&quot;&gt;\n\n使用总结：\n\nios 有拍照、录像、选取本地图片功能\n部分 android 只有选取本地图片功能\nwinphone 不支持\ninput 控件默认外观丑陋\n\n16. 消除 transition 闪屏.css&#123;\n    &#x2F;*设置内嵌的元素在 3D 空间如何呈现：保留 3D*&#x2F;\n    -webkit-transform-style: preserve-3d;\n    &#x2F;*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*&#x2F;\n    -webkit-backface-visibility: hidden;\n&#125;\n\n开启硬件加速\n解决页面闪白\n保证动画流畅\n\n.css &#123;\n   -webkit-transform: translate3d(0, 0, 0);\n   -moz-transform: translate3d(0, 0, 0);\n   -ms-transform: translate3d(0, 0, 0);\n   transform: translate3d(0, 0, 0);\n&#125;\n\n设计高性能 CSS3 动画的几个要素\n尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画\n不使用 position 的 left 和 top 来定位\n利用 translate3D 开启 GPU 加速\n\n17. android 上去掉语音输入按钮input::-webkit-input-speech-button &#123;display: none&#125;\n\n移动端事件相关1. 动端 touch 事件(区分 webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的 touch 事件\n以下支持 webkit\n\ntouchstart——当手指触碰屏幕时候发生。不管当前有多少只手指\ntouchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 event 的 preventDefault()* 可以阻止默认情况的发生：阻止页面滚动\ntouchend——当手指离开屏幕时触发\ntouchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面 alert()一个提示框，此时会触发该事件，这个事件比较少用\n\n以下支持 winphone 8\n\nMSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指\nMSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用 css 的 html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动\nMSPointerUp——当手指离开屏幕时触发\n\n2. 移动端 click 屏幕产生 200-300 ms 的延迟响应以下是历史原因：2007 年苹果发布首款 iphone 上 IOS 系统搭载的 safari 为了将适用于 PC 端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个 PC 上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。\n双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。\n原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先 Hold 一段时间 t，如果在 t 时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果 t 时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间 t 有多少呢？在 IOS safari 下，大概为 300 毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于 web 开发者来说是，页面 js 捕获 click 事件的回调函数处理，需要 300ms 后才生效，也就间接导致影响其他业务逻辑的处理。\n解决方案：\n\nfastclick 可以解决在手机上点击事件的 300ms 延迟\nzepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题\n\n触摸事件的响应顺序\n1、ontouchstart2、ontouchmove3、ontouchend4、onclick\n解决 300ms 延迟的问题，也可以通过绑定 ontouchstart 事件，加快对事件的响应\n3. 屏幕旋转的事件和样式事件window.orientation，取值：正负 90 表示横屏模式、0 和 180 表现为竖屏模式；\nwindow.onorientationchange &#x3D; function () &#123;\n  switch (window.orientation) &#123;\n    case -90:\n    case 90:\n      alert(&#39;横屏:&#39; + window.orientation)\n    case 0:\n    case 180:\n      alert(&#39;竖屏:&#39; + window.orientation)\n      break\n  &#125;\n&#125;\n\n样式&#x2F;&#x2F;竖屏时使用的样式\n@media all and (orientation:portrait) &#123;\n    .css&#123;&#125;\n&#125;\n\n&#x2F;&#x2F;横屏时使用的样式\n@media all and (orientation:landscape) &#123;\n    .css&#123;&#125;\n&#125;\n\n4. audio 元素和 video 元素在 ios 和 andriod 中无法自动播放应对方案：触屏即播\ndocument.addEventListener(\n  &#39;touchstart&#39;,\n  function () &#123;\n    audio.play()\n  &#125;,\n  true\n)\n","slug":"移动端 web 开发技巧","date":"2019-04-20T11:46:18.000Z","categories_index":"Mobile","tags_index":"Mobile","author_index":"Bobby's Blog"},{"id":"1da5fd0891b1fb5f2f44e192cd8c68c6","title":"Parcel 入门实践","content":"Webpack 是目前最多人使用的前端打包工具，但 webpack 功能强大，导致配置比较复杂（各种对应转换 loader，各种插件等），如果配置不合理还可能导致打包速度过慢。最近出现了一款新的打包工具 Parcel，受关注程度不亚于 Webpack。Parcel 是一个 Web 应用程序 打包器(bundler)，与以往的开发人员使用的打包器有所不同。它利用多核处理提供极快的性能，并且你不需要进行任何配置。\n英文：https://en.parceljs.org/中文：http://www.parceljs.io/Github: https://github.com/parcel-bundler/parcel\n\n\n全局安装&#x2F;&#x2F;Yarn:\nyarn global add parcel-bundler\n\n&#x2F;&#x2F;npm\nnpm install -g parcel-bundler\n\n初始化项目&#x2F;&#x2F;创建目录\nmkdir parcel\n\n&#x2F;&#x2F;创建package.json 文件\ncd parcel\nyarn init -y or npm init -y\n\n&#x2F;&#x2F;创建index.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;parcel&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;css&#x2F;style.css&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;h1&gt;\n        &lt;p&gt;hello Bobby&lt;&#x2F;p&gt;\n    &lt;&#x2F;h1&gt;\n\n    &lt;script src&#x3D;&quot;.&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n&#x2F;&#x2F;创建index.js\nconsole.log(&#39;test&#39;);\n\n&#x2F;&#x2F;创建style.css\nh1 &#123;\n\tcolor: #fff;\n\tfont-size: 50px;\n\tdisplay: -webkit-box;\n\tdisplay: -ms-flexbox;\n\tdisplay: flex;\n\t-webkit-box-pack: center;\n\t-ms-flex-pack: center;\n\tjustify-content: center;\n\t-webkit-box-align: center;\n\t-ms-flex-align: center;\n\talign-items: center;\n\t-webkit-box-orient: vertical;\n\t-webkit-box-direction: normal;\n\t-ms-flex-direction: column;\n\tflex-direction: column;\n\twidth: 100%;\n\theight: 100%;\n\tbackground: url(..&#x2F;images&#x2F;brand.jpg) no-repeat center;\n&#125;\n\n运行编译命令\n\n在浏览器中打开 http://localhost:1234/\n\n除了纯 CSS ，还支持其他编译成 CSS 语言，如 LESS ，SASS 和 Stylus ，并以相同的方式工作SCSS 编译需要 node-sass 模块。可以用 npm 来安装它：\nnpm install node-sass\n\n&#x2F;&#x2F;在 JavaScript 文件中导入 SCSS 文件\nimport &#39;..&#x2F;js&#x2F;custom.scss&#39;\n\n尽管许多 打包器(bundler) 都要求你安装和配置插件来转换资源，Parcel 内置许多长江的转换和转译器，让你开箱即用。你可以使用 Babel 转换 JavaScript，CSS 使用 PostCSS ，HTML 使用 PostHTML 。当在模块中找到配置文件（例如 .babelrc ，.postcssrc ）时， Parcel 会自动运行这些转换。\nBabelnpm insatll babel-preset-env\n\n&#x2F;&#x2F;创建一个 .babelrc 文件\n&#123;\n  &quot;presets&quot;: [&quot;env&quot;]\n&#125;\n\nPostCSSnpm install postcss-modules autoprefixer\n\n&#x2F;&#x2F;创建一个 .postcssrc 文件\n&#123;\n  &quot;modules&quot;: true,\n  &quot;plugins&quot;: &#123;\n    &quot;autoprefixer&quot;: &#123;\n      &quot;grid&quot;: true\n    &#125;\n  &#125;\n&#125;\n\n目录结构\n\nParcel 优点\n快速打包 - 多核编译，以及文件系统缓存，即使在重新启动之后也能快速重新构建。\n支持 JS，CSS，HTML，文件资源等- 不需要安装任何插件。\n在需要的时候自动使用 Babel，PostCSS 和 PostHTML 自动转换模块 - 甚至是 node_modules。\n零配置代码拆分，使用动态 import 语句分割。\n内置支持模块热替换\n友好的错误记录体验，语法突出显示的代码帧有助于查明问题。\n\n比较\n\n\n打包器\n时间\n\n\n\nbrowserify\n22.98s\n\n\nwebpack\n20.71s\n\n\nparcel\n9.98s\n\n\nparcel - with cache\n2.64s\n\n\n","slug":"Parcel配置","date":"2018-12-25T13:50:36.000Z","categories_index":"Parcel","tags_index":"Parcel","author_index":"Bobby's Blog"},{"id":"c2607e9298e419e91fd4a6508ed0ae1d","title":"理解JS继承方式","content":"1.原型继承模式&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 原型继承方式\nChild.prototype &#x3D; new Parent();\nChild.prototype.constructor &#x3D; Child; &#x2F;&#x2F;因为上面的代码把Child的prototype指向了Parent\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18); &#x2F;&#x2F;希望: 子类继承父类的属性和方法\nvar son2 &#x3D; new Child(&#39;Bob&#39;, 20);\nson1.run();  &#x2F;&#x2F;从Parent原型上继承的方法\nson1.foods.push(&#39;橘子&#39;);\n\nconsole.log(son1.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;, &#39;橘子&#39;]\nconsole.log(son2.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;, &#39;橘子&#39;]\n\n优点：1.简单,易于实现\n\n缺点：1. 子类的构造函数的参数(创建子类实例的参数),没法传递给父类的构造函数\n     2. 子类原型的constructor会被改变，需要自己改回来\n     3. 如果父类有引用类型的属性,那么所有的子类会共享这个引用类型(修改son1.foods后son2.foods也变了，因为来自原型对象的引用属性是所有实例共享的)\n\n\n\n2.构造函数继承模式&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n  this.fun &#x3D; function() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  &#x2F;&#x2F;使用借用构造函数继承模式来构建对象的实例属性\n  Parent.call(this, name, age); &#x2F;&#x2F;核心\n&#125;\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\n\n核心： 借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）\n\n优点：1. 解决子类实例共享父类引用属性的问题\n     2. 创建子类实例时，可以向父类构造函数传参\n\n缺点：1. 方法都在构造函数中定义, 无法实现函数方法复用，每次创建实例都会创建一遍方法，太多了就会影响性能，占用内存\n\n3.组合继承模式&#x2F;&#x2F; 组合了: 原型继承模式和构造函数继承模式\n\n&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  Parent.call(this, name, age); &#x2F;&#x2F;借用父类的构造函数，给子类创建实例属性\n&#125;\n\n&#x2F;&#x2F; 原型继承方式\nChild.prototype &#x3D; new Parent();\nChild.prototype.constructor &#x3D; Child; &#x2F;&#x2F;因为上面的代码把Child的prototype指向了Parent\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\n\n核心: 把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Parent.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Child.prototype &#x3D; new Parent();继承父类函数，实现函数复用\n\n核心: 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式\n\n优点：1. 不存在引用属性共享问题\n     2. 可传参\n     3. 函数可复用\n\n缺点：1. 父类构造函数被调用了两次\n\n4.原型式继承模式&#x2F;&#x2F; 原型式继承的方法，传一个对象，内部新构造一个对象，新对象的原型指向o对象\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\nvar o &#x3D; &#123;name: &#39;Jack, age: 18, foods: [&#39;苹果&#39;，&#39;香蕉&#39;]&#125;;\n\nvar obj &#x3D; createObj(o);\n\nconsole.log(obj.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;]\nobj.age &#x3D; 20; &#x2F;&#x2F; 修改属性\n\n优点：1. 不需要使用new构造函数就可以直接构造另外的其他对象\n\n缺点：1. 所有构造出来的实例会共享 原型对象上的引用类型的属性\n\n* ES5通过Object.create()方法规范了原型式继承, 可以接受两个参数，一个是用作新对象原型的对象和一个可选的为新对象定义额外属性的对象，行为相同，基本用法和上面的object一样，除了object不能接受第二个参数以外\n\nvar person &#x3D; &#123;\n  name: ‘Jiang’,\n  friends: [‘Shelby’, ‘Court’]\n&#125;\nvar anotherPerson &#x3D; Object.create(person)\nconsole.log(anotherPerson.friends)  &#x2F;&#x2F; [‘Shelby’, ‘Court’]\n\n5.寄生继承模式&#x2F;&#x2F; 原型式继承的方法，传一个对象，内部新构造一个对象，新对象的原型指向o对象\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\n&#x2F;&#x2F; 寄生继承方式：其实就是传一个对象到一个方法(工厂方法), 方法内部根据传来的对象新构造一个新对象, 并对新对象进行拓展增强, 返回这个新对象\nfunction inheritObj(p) &#123;\n  var o &#x3D; createObj(p); &#x2F;&#x2F; 同p对象构造一个新对象o\n  o.say &#x3D; function() &#123; &#x2F;&#x2F; 对新对象o进行拓展\n    &#x2F;&#x2F;...\n  &#125;\n  return o;\n&#125;\n\n6.寄生组合继承模式&#x2F;&#x2F; 组合了: 寄生继承模式和借用构造函数继承模式\n\n&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  &#x2F;&#x2F;使用借用构造函数继承模式来构建对象的实例属性\n  Parent.call(this, name, age);\n&#125;\n\n&#x2F;&#x2F; 寄生继承的方法\nChild.prototype &#x3D; inheritFrom(Parent.prototype);\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\nvar son2 &#x3D; new Child(&#39;Bob&#39;, 20);\nson1.run();\nson2.run();\n\n&#x2F;&#x2F; 寄生继承模式\ninheritFrom(o) &#123;\n  var t &#x3D; createObj(o);\n  t.constructor &#x3D; Child; &#x2F;&#x2F;把Child原型上的构造函数指向Child构造函数\n  return t;\n&#125;\n\n&#x2F;&#x2F; 原型式继承的方法\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\n或者\n---------------------------\n&#x2F;&#x2F; 寄生继承模式\nfunction prototype(child, parent) &#123;\n    var prototype &#x3D; createObj(parent.prototype);\n    prototype.constructor &#x3D; child;\n    child.prototype &#x3D; prototype;\n&#125;\n\n&#x2F;&#x2F; 当我们使用的时候：\nprototype(Child, Parent);\n\n","slug":"理解JS继承方式","date":"2018-09-20T14:05:28.000Z","categories_index":"JS","tags_index":"JS","author_index":"Bobby's Blog"},{"id":"9f17109abe732a77d87a2b0d4189145c","title":"详解JS遍历","content":"遍历数组或对象是一名程序员的基本素养之一，然而遍历却不是一件简单的事，优秀的程序员知道怎么去选择合适的遍历方法，优化遍历效率。本篇将带你走进 JavaScript 遍历的世界，享受分析 JS 循环的快感。本篇所有代码都可以直接运行，希望您通读本篇后，不止是浏览， 最好是亲手去实践下。\n\n\njs 有如下两种数据需要经常遍历\n数组(Array)\n对象(Object)\n\n同时又提供了如下 8 种方法方便我们遍历数据\n\nfor\nwhile(或 do~while)\nforEach\nfor in\n$.each\n$(selecter).each\nmap\nevery\n\n通常我们需要根据数据选择合适的遍历方法，优化遍历效率，提高开发效率接下来针对如下两种数据进行详细的分析和举栗:\nvar array &#x3D; [&#39;vue&#39;, &#39;react&#39;, &#39;angular&#39;]\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 3 &#125;\n\nfor语法: for(初始化; 循环执行条件; 每遍历一个元素后做的事情;){}\n;(function () &#123;\n  &#x2F;&#x2F;循环置于闭包之内\n  for (var i &#x3D; 0, length &#x3D; array.length; i &lt; length; i++) &#123;\n    &#x2F;&#x2F;缓存数组长度\n    console.log(array[i]) &#x2F;&#x2F;vue react angular\n  &#125;\n&#125;)()\n\nfor 循环只能遍历数组, 不能遍历对象. 写 for 循环时有两点需要注意：\n\n其一,为了避免遍历时执行多遍计算数组长度的操作,影响效率,建议在循环开始以变量的形式缓存下数组长度, 若在循环内部有可能改变数组长度, 请务必慎重处理, 避免数组越界.\nJavaScript 中并没有类似 java 的块级作用域, for 循环内部定义的变量会直接暴露在外(如 i,循环退出后,i 变量将等于数组长度, 后续代码将能访问到 i 变量的值), 因此建议将 for 循环置于闭包内. 特别要注意的是: 如果在循环内部, 前一个元素的遍历有可能影响到后一个元素的遍历, 那么 for 循环内部方法也需要置于闭包之内.\n\ndo/while语法: do{…}while(true);\n;(function () &#123;\n  var i &#x3D; 0,\n    len &#x3D; array.length\n  do &#123;\n    if (i &#x3D;&#x3D; 2) &#123;\n      break &#x2F;&#x2F; 循环被终止, 此处如果是continue就会造成循环无法退出\n    &#125;\n    console.log(&#39;array[&#39; + i + &#39;]:&#39; + array[i])\n    i++ &#x2F;&#x2F;此句建议放置循环while头部\n  &#125; while (i &lt; len)\n&#125;)()\n\ndo/while 的语法简化了循环的实现, 只保留对循环条件的判断, 所以我们要在循环内部构造出循环退出的条件, 否则有可能造成死循环. 特别要注意的是: 使用 continue 跳出本次遍历时, 要保证循环能够自动进入到下一次遍历, 因此保证循环走到下一次遍历的语句需要放到 continue 前面执行, 建议置于循环头部.(如上, i++ 语句最好放置循环头部)\ndo/while 循环与 for 循环大体差不多,只支持数组遍历, 多用于对循环退出条件不是很明确的场景. 一般来说不建议使用这种方式遍历数组.\nforEach语法: array.forEach(function(item){}), 参数 item 表示数组每一项的元素\narray.forEach(function (item) &#123;\n  if (item &#x3D;&#x3D; &#39;react&#39;) return &#x2F;&#x2F;这里只能使用return跳过当前元素处理\n  console.log(item) &#x2F;&#x2F;vue angular\n&#125;)\n\nforEach 回调 function 默认有三个参数: item, index, array.使用 forEach 循环有几点需要特别注意:\n\nforEach 无法遍历对象\nforEach 无法在 IE 中使用，只是在 firefox 和 chrome 中实现了该方法\nforEach 无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致\n\nfor in语法: for(var item in array){}\nfor (var item in array) &#123;\n  console.log(item) &#x2F;&#x2F;0 1 2\n&#125;\nfor (var item in obj) &#123;\n  console.log(item) &#x2F;&#x2F;0 1 2 length\n&#125;\n\nfor in 可用于遍历数组和对象, 但它输出的只是数组的索引和对象的 key, 我们可以通过索引和 key 取到对应的值. 如下:\nfor (var item in array) &#123;\n  console.log(array[item]) &#x2F;&#x2F;vue react angular\n&#125;\nfor (var item in obj) &#123;\n  console.log(obj[item]) &#x2F;&#x2F;vue react angular 3\n&#125;\n\n$.each语法: $.each(array|obj, function(i, ele){}) 支持数组和对象\n$.each(array, function (i, ele) &#123;\n  console.log(i, ele, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot; true\n&#x2F;&#x2F;1 &quot;react&quot; true\n&#x2F;&#x2F;2 &quot;angular&quot; true\n\n$.each(obj, function (i, ele) &#123;\n  console.log(i, ele, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot; true\n&#x2F;&#x2F;1 &quot;react&quot; true\n&#x2F;&#x2F;2 &quot;angular&quot; true\n\n这里我们注意到 this 对象 指向当前属性的值,这是因为:参考 jQuery api:\n\n\n\n\n\n\n\n\n\n$.each()方法会迭代 jQuery 对象中的每一个 DOM 元素。每次回调函数执行时，会传递当前循环次数作为参数(从 0 开始计数)。更重要的是，回调函数是在当前 DOM 元素为上下文的语境中触发的。因此关键字 this 总是指向这个元素。\n同时,上述遍历时, obj 对象的属性中有一个 length 属性并没有被输出. 这是为什么呢? 请耐心往下看.首先, 我们来看看遍历对象 obj 时, 当前的 this 对象到底是什么?\n$.each(obj, function (i, ele) &#123;\n  if (this &#x3D;&#x3D; &#39;linda&#39;) &#123;\n    &#x2F;&#x2F;我们随机选取第一个属性\n    console.log(this, this &#x3D;&#x3D; ele)\n    $.each(this, function (e, ele2) &#123;\n      console.log(e, ele2)\n    &#125;)\n  &#125;\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; true\n&#x2F;&#x2F;&quot;v&quot;\n&#x2F;&#x2F;&quot;u&quot;\n&#x2F;&#x2F;&quot;e&quot;\n\n我们发现, this 对象等于回调函数的第二个形参. 且它的 length 属性和 [[PrimitiveValue]] 属性并没有被打印出来, 为此我们来查看下 length 的内部属性.\n$.each(obj, function (i, ele) &#123;\n  if (this &#x3D;&#x3D; &#39;vue&#39;)\n    &#x2F;&#x2F;我们还是随机选取第一个属性(这还是随机吗?)\n    console.log(Object.getOwnPropertyDescriptor(this, &#39;length&#39;))\n&#125;)\n&#x2F;&#x2F;Object &#123;value: 3, writable: false, enumerable: false, configurable: false&#125;\n\n可见, this 对象的 length 属性的 enumerable 属性被设置成了 false, 这表示该对象不能被列举或遍历, 同时还不能被配置(configurable: false), 也不能被赋值(writable: false).\n此时, 前面遍历 obj 对象时,它的 length 属性没有被打印出来的疑问似乎有解了. 让我们来看看 obj.length 的内部属性吧.\nconsole.log(Object.getOwnPropertyDescriptor(obj, &#39;length&#39;))\n&#x2F;&#x2F;Object &#123;value: 3, writable: true, enumerable: true, configurable: true&#125;\n\nobj.length 值为 3, 可赋值, 可列举, 可配置. 这可不对, 刚刚不是说 enumerable 属性被设置成了 false 才不会被遍历吗. 现在该值为 true, 并且还不可遍历. 这不合常理, 自然该有别的原因. 我们接着往下看.\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 1 &#125; &#x2F;&#x2F; 试着改变length的值\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot;\n\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 5 &#125; &#x2F;&#x2F; 坚持改变length的值\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F; 0 vue\n&#x2F;&#x2F; 1 react\n&#x2F;&#x2F; 2 angular\n&#x2F;&#x2F; length 5\n\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39; &#125; &#x2F;&#x2F; 试试去掉length属性\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F; 0 vue\n&#x2F;&#x2F; 1 react\n&#x2F;&#x2F; 2 angular\n\n现象明了, 结合 jquery 源码, 当对象中存在 length 属性时, $.each 内部使用for循环去遍历对象, 否则它将使用for in循环去遍历, 因此$.each 遍历对象遵循如下规律:\n\n如果对象中存在 length 属性, 遍历深度以 length 属性为准, 即 length 多大, 遍历多少个元素.\n如果对象中不存在 length 属性, 遍历深度以实际内部属性个数为准.\n\n不仅如此, $.each 的具体使用过程中还有以下几点需要注意:\n\n使用 return 或者 return true 为跳过一个元素，继续执行后面的循环;\n使用 return false 为终止循环的执行, 这是因为在 jquery.each 中,若返回值指定为 false,才跳出循环, 如果感兴趣请翻看 jquery.each 源码;\n无法使用 break 与 continue 来跳过循环.\n\n$(selecter).each语法: $(selecter|array|o).each(function(i, ele){}) 支持数组和对象,该方法基本上与$.each 方法相同.\n$(&#39;div&#39;).each(function (i, ele) &#123;\n  console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;dom... 0 true\n\n$(array).each(function (i, ele) &#123;\n  &#x2F;&#x2F;处理数组\n  if (this &#x3D;&#x3D; &#39;vue&#39;) console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; 0 true\n\n$(obj).each(function (i, ele) &#123;\n  &#x2F;&#x2F;处理对象\n  if (this &#x3D;&#x3D; &#39;vue&#39;) console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; 0 true\n\ndom 表示 div 元素, 由于 this 恒等 ele, 说明 this 也表示 div 元素, 所以 this 并不是 jquery 对象, 而是普通的 DOM 对象(可以在 this 上随意使用 DOM 方法).使用$(selecter).each 方法,请注意以下几点:\n\ni: 即序列值 ele: 表示当前被遍历的 DOM 元素\nthis 表示当前被遍历的 DOM 元素，不能调用 jQuery 方法, 如需调用 jquery 方法需要用$符号包裹.如, $(this)\n\nmap即 Array.prototype.map,该方法只支持数组语法: array.map(callback[,thisArg]) map 方法使用其提供函数的每次返回结果生成一个新的数组.\nvar array &#x3D; [1, 4, 9]\nvar roots &#x3D; array.map(Math.sqrt) &#x2F;&#x2F;map包裹方法名\n&#x2F;&#x2F; roots is now [1, 2, 3], array is still [1, 4, 9]\n\nvar array &#x3D; [1, 4, 9]\nvar doubles &#x3D; array.map(function (num) &#123;\n  &#x2F;&#x2F;map包裹方法实体\n  return num * 2\n&#125;)\n&#x2F;&#x2F; doubles is now [2, 8, 18]. array is still [1, 4, 9]\n\n实际上,由于 map 方法被设计成支持 [鸭式辨型][] , 该方法也可以用来处理形似数组的对象, 例如 NodeList.\nvar elems &#x3D; document.querySelectorAll(&#39;select option:checked&#39;)\nvar values &#x3D; Array.prototype.map.call(elems, function (obj) &#123;\n  return obj.value\n&#125;)\n\n甚至还可以用来处理字符串, 如下:\nvar map &#x3D; Array.prototype.map\nvar array &#x3D; map.call(&#39;Hello 中国&#39;, function (x) &#123;\n  return x.charCodeAt(0)\n&#125;)\nconsole.log(array)\n&#x2F;&#x2F;[72, 101, 108, 108, 111, 32, 20013, 22269]\n\nmap 处理字符串的方式多种多样, 例如 反转等.\nvar str &#x3D; &#39;12345&#39;\nvar output &#x3D; Array.prototype.map\n  .call(str, function (x) &#123;\n    return x\n  &#125;)\n  .reverse()\n  .join(&#39;&#39;)\nconsole.log(output) &#x2F;&#x2F;54321\n\n例如 将字符串数组转换为数字数组, 只需一条语句, 如下:\nconsole.log([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(Number)) &#x2F;&#x2F;[1,2,3]\n\n目前 map 方法被大部分浏览器支持, 除了 IE 6,7,8.\nevery即 Array.prototype.every, 该方法同上述 map 方法也只支持数组语法: arr.every(callback[, thisArg]) every 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回 true, 反之则返回 false.\nfunction isBigEnough(element, index, array) &#123;\n  return element &gt;&#x3D; 10\n&#125;\n;[12, 5, 8, 130, 44].every(isBigEnough) &#x2F;&#x2F; false\n;[12, 54, 18, 130, 44].every(isBigEnough) &#x2F;&#x2F; true\n\n该方法还有简写方式, 如下:\n;[12, 5, 8, 130, 44].every((elem) &#x3D;&gt; elem &gt;&#x3D; 10) &#x2F;&#x2F; false\n;[12, 54, 18, 130, 44].every((elem) &#x3D;&gt; elem &gt;&#x3D; 10) &#x2F;&#x2F; true\n\n以上, 遍历数组和对象的 8 种方法简单的介绍完, 小结如下:\n\nfor in , $.each , $().each 既支持对象也支持数组遍历;\nfor , do/while , forEach 只支持数组;\nArray.prototype.map, Array.prototype.every 只支持数组和形似数组的对象;\nforEach 不能退出循环,只能通过 return 来进入到下一个元素的遍历中(相当于 for 循环的 continue), 且在 IE 没有实现该方法;\n$.each和$().each 循环只能通过 return false 来退出循环, 使用 return 或 return true 将跳过一个元素, 继续执行后面的循环.\n\n","slug":"详解JS遍历","date":"2018-07-20T14:19:44.000Z","categories_index":"JS","tags_index":"JS","author_index":"Bobby's Blog"},{"id":"bd0b4d58af50c3051be665f36056fa92","title":"Git 总结","content":"在团队做过软件开发的，版本控制必是不可或缺的一项。目前，版本控制主要分为集中式版本控制系统和分布式版本控制系统 ，即大家熟知的 SVN 和 Git。Git 是当下最流行的分布式版本控制系统。\n\n\n什么是版本控制版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\n\n实现跨区域多人协同开发\n追踪和记载一个或者多个文件的历史记录\n组织和保护你的源代码和文档\n统计工作量\n并行开发、提高开发效率\n跟踪记录整个软件的开发过程\n减轻开发人员的负担，节省时间，同时降低人为错误\n\n简单说就是用于管理多人协同开发项目的技术。\n常用术语1)、仓库（Repository）受版本控制的所有文件修订历史的共享数据库\n2)、工作空间（Workspace)本地硬盘或 Unix 用户帐户上编辑的文件副本\n3)、工作树/区（Working tree）工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。\n4)、暂存区（Staging area）暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化。\n\n5)、索引（Index）索引是暂存区的另一种术语。\n6)、签入（Checkin）将新版本复制回仓库\n7)、签出（Checkout）从仓库中将文件的最新修订版本复制到工作空间\n8)、提交（Commit）对各自文件的工作副本做了更改，并将这些更改提交到仓库\n9)、冲突（Conflict）多人对同一文件的工作副本进行更改，并将这些更改提交到仓库\n10)、合并（Merge）将某分支上的更改联接到此主干或同为主干的另一个分支\n11)、分支（Branch）从主线上分离开的副本，默认分支叫 master\n12)、锁（Lock）获得修改文件的专有权限。\n13)、头（HEAD）头是一个象征性的参考，最常用以指向当前选择的分支。\n14)、修订（Revision）表示代码的一个版本状态。Git 通过用 SHA1 hash 算法表示的 ID 来标识不同的版本。\n15)、标记（Tags）标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。\n什么是 GitGit 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n优点：\n适合分布式开发，强调个体。\n公共服务器压力和数据量都不会太大。\n速度快、灵活。\n任意两个开发者之间可以很容易的解决冲突。\n离线工作。\n\n缺点：\n模式上比 SVN 更加复杂。\n不符合常规思维。\n代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。\n\ngit 命令图解\n\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\ngit 命令大全git init                                                  # 初始化本地git仓库（创建新仓库）\ngit config --global user.name &quot;xxx&quot;                       # 配置用户名\ngit config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件\ngit config --global color.ui true                         # git status等命令自动着色\ngit config --global color.status auto\ngit config --global color.diff auto\ngit config --global color.branch auto\ngit config --global color.interactive auto\ngit config --global --unset http.proxy                    # remove  proxy configuration on git\ngit clone git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git             # clone远程仓库\ngit status                                                # 查看当前版本状态（是否修改）\ngit add xyz                                               # 添加xyz文件至index\ngit add .                                                 # 增加当前子目录下所有更改过的文件至index\ngit commit -m &#39;xxx&#39;                                       # 提交\ngit commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）\ngit commit -am &#39;xxx&#39;                                      # 将add和commit合为一步\ngit rm xxx                                                # 删除index中的文件\ngit rm -r *                                               # 递归删除\ngit log                                                   # 显示提交日志\ngit log -1                                                # 显示1行日志 -n为n行\ngit log -5\ngit log --stat                                            # 显示提交日志及相关变动文件\ngit log -p -m\ngit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容\ngit show dfb02                                            # 可只用commitid的前几位\ngit show HEAD                                             # 显示HEAD提交日志\ngit show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本\ngit tag                                                   # 显示已存在的tag\ngit tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的tag\ngit show v2.0                                             # 显示v2.0的日志及详细内容\ngit log v2.0                                              # 显示v2.0的日志\ngit diff                                                  # 显示所有未添加至index的变更\ngit diff --cached                                         # 显示所有已添加index但还未commit的变更\ngit diff HEAD^                                            # 比较与上一个版本的差异\ngit diff HEAD -- .&#x2F;lib                                    # 比较与HEAD版本lib目录的差异\ngit diff origin&#x2F;master..master                            # 比较远程分支master上有本地分支master上没有的\ngit diff origin&#x2F;master..master --stat                     # 只显示差异的文件，不显示具体内容\ngit remote add origin git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git # 增加远程定义（用于push&#x2F;pull&#x2F;fetch）\ngit branch                                                # 显示本地分支\ngit branch --contains 50089                               # 显示包含提交50089的分支\ngit branch -a                                             # 显示所有分支\ngit branch -r                                             # 显示所有原创分支\ngit branch --merged                                       # 显示所有已合并到当前分支的分支\ngit branch --no-merged                                    # 显示所有未合并到当前分支的分支\ngit branch -m master master_copy                          # 本地分支改名\ngit checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出\ngit checkout -b master master_copy                        # 上面的完整版\ngit checkout features&#x2F;performance                         # 检出已存在的features&#x2F;performance分支\ngit checkout --track hotfixes&#x2F;BJVEP933                    # 检出远程分支hotfixes&#x2F;BJVEP933并创建本地跟踪分支\ngit checkout v2.0                                         # 检出版本v2.0\ngit checkout -b devel origin&#x2F;develop                      # 从远程分支develop创建新本地分支devel并检出\ngit checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）\ngit merge origin&#x2F;master                                   # 合并远程master分支至当前分支\ngit cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改\ngit push origin master                                    # 将当前分支push到远程master分支\ngit push origin :hotfixes&#x2F;BJVEP933                        # 删除远程仓库的hotfixes&#x2F;BJVEP933分支\ngit push --tags                                           # 把所有tag推送到远程仓库\ngit fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）\ngit fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支\ngit pull origin master                                    # 获取远程分支master并merge到当前分支\ngit mv README README2                                     # 重命名文件README为README2\ngit reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）\ngit rebase\ngit branch -d hotfixes&#x2F;BJVEP933                           # 删除分支hotfixes&#x2F;BJVEP933（本分支修改已合并到其他分支）\ngit branch -D hotfixes&#x2F;BJVEP933                           # 强制删除分支hotfixes&#x2F;BJVEP933\ngit ls-files                                              # 列出git index包含的文件\ngit show-branch                                           # 图示当前分支历史\ngit show-branch --all                                     # 图示所有分支历史\ngit whatchanged                                           # 显示提交历史对应的文件修改\ngit revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818\ngit ls-tree HEAD                                          # 内部命令：显示某个git对象\ngit rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH\ngit reflog                                                # 显示所有提交，包括孤立节点\ngit show HEAD@&#123;5&#125;\ngit show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态\ngit log --pretty&#x3D;format:&#39;%h %s&#39; --graph                   # 图示提交日志\ngit show HEAD~3\ngit show -s --pretty&#x3D;raw 2be7fcb476\ngit stash                                                 # 暂存当前修改，将所有至为HEAD状态\ngit stash list                                            # 查看所有暂存\ngit stash show -p stash@&#123;0&#125;                               # 参考第一次暂存\ngit stash apply stash@&#123;0&#125;                                 # 应用第一次暂存\ngit grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”\ngit grep -e &#39;#define&#39; --and -e SORT_DIRENT\ngit gc\ngit fsck\n\n参考资料git 命令大全阮一峰老师的常用 Git 命令清单\n","slug":"Git总结","date":"2018-07-11T15:37:45.000Z","categories_index":"Git","tags_index":"Git","author_index":"Bobby's Blog"},{"id":"bfff9943662c3aacf871abc5e37a1cbd","title":"常用的javaScript正则表达式","content":"常用的 javaScript 正则表达式\n\n\n\n\n\n\n\n\n常用的 javaScript 正则表达式，其中包括用户名、密码强度、电子邮件地址（Email）、手机号码、身份证号、URL 地址、 IPv4 地址、 十六进制颜色、 日期、 整数、数字、QQ 号码、 微信号、车牌号、中文正则。\n\n\n用户名正则&#x2F;&#x2F;用户名正则，4到16位（字母，数字，下划线，减号）\nvar uPattern &#x3D; &#x2F;^[a-zA-Z0-9_-]&#123;4,16&#125;$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(uPattern.test(&#39;bobby&#39;))\n\n密码强度正则&#x2F;&#x2F;密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\nvar pPattern &#x3D; &#x2F;^.*(?&#x3D;.&#123;6,&#125;)(?&#x3D;.*\\d)(?&#x3D;.*[A-Z])(?&#x3D;.*[a-z])(?&#x3D;.*[!@#$%^&amp;*? ]).*$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(pPattern.test(&#39;isBobby520#&#39;))\n\nEmail 正则&#x2F;&#x2F;Email正则\nvar ePattern &#x3D; &#x2F;^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(ePattern.test(&#39;12345678@qq.com&#39;))\n\n手机号码正则&#x2F;&#x2F;手机号正则\nvar mPattern &#x3D; &#x2F;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d&#123;8&#125;$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(mPattern.test(&#39;18600000000&#39;))\n\n身份证号正则&#x2F;&#x2F;身份证号（18位）正则\nvar cP &#x3D; &#x2F;^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(cP.test(&#39;11010519880605371X&#39;))\n\nURL 正则&#x2F;&#x2F;URL正则\nvar urlP &#x3D; &#x2F;^((https?|ftp|file):\\&#x2F;\\&#x2F;)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\&#x2F;\\w \\.-]*)*\\&#x2F;?$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(urlP.test(&#39;http:&#x2F;&#x2F;42du.cn&#39;))\n\nIPv4 地址正则&#x2F;&#x2F;ipv4地址正则\nvar ipP &#x3D; &#x2F;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(ipP.test(&#39;115.28.47.26&#39;))\n\n日期正则&#x2F;&#x2F;日期正则，简单判定,未做月份及日期的判定\nvar dP1 &#x3D; &#x2F;^\\d&#123;4&#125;(\\-)\\d&#123;1,2&#125;\\1\\d&#123;1,2&#125;$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(dP1.test(&#39;2017-05-11&#39;))\n&#x2F;&#x2F;输出 true\nconsole.log(dP1.test(&#39;2017-15-11&#39;))\n&#x2F;&#x2F;日期正则，复杂判定\nvar dP2 &#x3D;\n  &#x2F;^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(dP2.test(&#39;2017-02-11&#39;))\n&#x2F;&#x2F;输出 false\nconsole.log(dP2.test(&#39;2017-15-11&#39;))\n&#x2F;&#x2F;输出 false\nconsole.log(dP2.test(&#39;2017-02-29&#39;))\n\n十六进制颜色正则&#x2F;&#x2F;RGB Hex颜色正则\nvar cPattern &#x3D; &#x2F;^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(cPattern.test(&#39;#b8b8b8&#39;))\n\n整数正则&#x2F;&#x2F;正整数正则\nvar posPattern &#x3D; &#x2F;^\\d+$&#x2F;\n&#x2F;&#x2F;负整数正则\nvar negPattern &#x3D; &#x2F;^-\\d+$&#x2F;\n&#x2F;&#x2F;整数正则\nvar intPattern &#x3D; &#x2F;^-?\\d+$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(posPattern.test(&#39;42&#39;))\n&#x2F;&#x2F;输出 true\nconsole.log(negPattern.test(&#39;-42&#39;))\n&#x2F;&#x2F;输出 true\nconsole.log(intPattern.test(&#39;-42&#39;))\n\n数字正则可以是整数也可以是浮点数\n\n&#x2F;&#x2F;正数正则\nvar posPattern &#x3D; &#x2F;^\\d*\\.?\\d+$&#x2F;\n&#x2F;&#x2F;负数正则\nvar negPattern &#x3D; &#x2F;^-\\d*\\.?\\d+$&#x2F;\n&#x2F;&#x2F;数字正则\nvar numPattern &#x3D; &#x2F;^-?\\d*\\.?\\d+$&#x2F;\nconsole.log(posPattern.test(&#39;42.2&#39;))\nconsole.log(negPattern.test(&#39;-42.2&#39;))\nconsole.log(numPattern.test(&#39;-42.2&#39;))\n\nQQ 号码正则&#x2F;&#x2F;QQ号正则，5至11位\nvar qqPattern &#x3D; &#x2F;^[1-9][0-9]&#123;4,10&#125;$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(qqPattern.test(&#39;12345678&#39;))\n\n微信号正则&#x2F;&#x2F;微信号正则，6至20位，以字母开头，字母，数字，减号，下划线\nvar wxPattern &#x3D; &#x2F;^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(wxPattern.test(&#39;oOBobbyOo&#39;))\n\n车牌号正则&#x2F;&#x2F;车牌号正则\nvar cPattern &#x3D; &#x2F;^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(cPattern.test(&#39;粤K38106&#39;))\n\n包含中文正则&#x2F;&#x2F;包含中文正则\nvar cnPattern &#x3D; &#x2F;[\\u4E00-\\u9FA5]&#x2F;\n&#x2F;&#x2F;输出 true\nconsole.log(cnPattern.test(&#39;42度&#39;))\n\n校验数字正则数字：^[0-9]*$\nn位的数字：^\\d&#123;n&#125;$\n至少n位的数字：^\\d&#123;n,&#125;$\nm-n位的数字：^\\d&#123;m,n&#125;$\n零和非零开头的数字：^(0|[1-9][0-9]*)$\n非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$\n带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$\n正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$\n有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$\n非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$\n非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$\n非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n\n校验字符正则汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$\n英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$\n长度为3-20的所有字符：^.&#123;3,20&#125;$\n由26个英文字母组成的字符串：^[A-Za-z]+$\n由26个大写英文字母组成的字符串：^[A-Z]+$\n由26个小写英文字母组成的字符串：^[a-z]+$\n由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$\n中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$\n可以输入含有^%&amp;&#39;,;&#x3D;?$\\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\\x22]+\n禁止输入含有~的字符：[^~\\x22]+\n\n特殊需求正则Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?\nInternetURL：&lt;[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$&lt;\n手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$\n电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$\n国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;\n身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$\n短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$\n日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\nxml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)\n腾讯QQ号：^[1-9][0-9]&#123;4,&#125;$    (腾讯QQ号从10000开始)\n中国邮政编码：^[1-9]\\d&#123;5&#125;(?!\\d)$    (中国邮政编码为6位数字)\nIP地址：^\\d+\\.\\d+\\.\\d+\\.\\d+$    (提取IP地址时有用)\nIPv4地址：^((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))$\n","slug":"常用的JS正则表达式","date":"2018-06-27T11:30:16.000Z","categories_index":"Regex","tags_index":"Regex","author_index":"Bobby's Blog"},{"id":"6c8c7b5d1ee2282dcd4144a2e2072c08","title":"Web Storage - HTML5本地存储","content":"Web Storage 是 HTML5 引入的一个非常重要的功能，在前端开发中经常用到，可以在客户端本地存储数据，类似 HTML4 的 cookie，但可实现功能要比 cookie 强大的多，cookie 大小被限制在 4KB，Web Storage 官方建议为每个网站 5MB。\n\n\nWeb Storage 其相对于 cookie 来说有以下几点优势：\n存储空间大：cookie 只有 4KB 的存储空间，而 Web Storage 在官方建议中为每个网站 5M。\n可选择性强：Web Storage 分为两种：sessionStorage 和 localStorage\n\nWeb Storage 的使用方法在使用上，session Storage 和 local Storage 大同小异，只是 session Storage 是将数据临时存储在 session 中，浏览器关闭，数据随之消失。而 local Storage 则是将数据存储在本地，理论上来说数据永远不会消失，除非人为删除。\nAPI：\n保存数据 localStorage.setItem(key, value); sessionStorage.setItem(key, value);\n读取数据 localStorage.getItem(key); sessionStorage.getItem( key );\n删除单个数据 localStorage.removeItem(key); sessionStorage.removeItem(key);\n删除全部数据 localStorage.clear(); sessionStorage.clear();\n获取索引的 keylocalStorage.key(index); sessionStorage.key(index);\n\n注意：Web Storage 的 API 只能操作字符串\n\n在使用 Web Storage 之前，我们需要注意以下几点：\n\n仅支持支持 IE8 及以上版本\n由于只能对字符串类型数据进行操作，所以对一些 JSON 对象需要进行转换\n因为是明文存储，所以毫无隐私性可言，绝对不能用于存储重要信息\n会是浏览器加载速度在一定程度上变慢\n无法被爬虫程序爬取\n\n使用 Web Storage 之前，请加上以下代码，对浏览器对 Web Storage 的支持性进行判断:\nif (window.localStorage) &#123;\n  &#x2F;&#x2F;或者 window.sessionStorage\n  alert(&#39;浏览支持localStorage&#39;)\n&#125; else &#123;\n  alert(&#39;浏览暂不支持localStorage&#39;)\n&#125;\n\n&#x2F;&#x2F;或者\nif (typeof window.localStorage &#x3D;&#x3D; &#39;undefined&#39;) &#123;\n  &#x2F;&#x2F;或者 window.sessionStorage\n  alert(&#39;浏览暂不支持localStorage&#39;)\n&#125;\n\n用法以 localStorage 为例，sessionStorage 用法一样：\nsetItem保存数据：localStorage.setItem(key,value);\n&#x2F;&#x2F;示例：\nlocalStorage.setItem(&#39;name&#39;, &#39;Hello World&#39;)\n\n当 key 相同时会覆盖之前的 value，用于修改数据。如果 value 为对象，需转为 json 字符串，否则你读取出来的将会是 [object Object]\ngetItem读取数据：localStorage.getItem(key);\n&#x2F;&#x2F;示例：\nlocalStorage.getItem(&#39;name&#39;) &#x2F;&#x2F; Hello World\n\nremoveItem删除单个数据：localStorage.removeItem(key);\n&#x2F;&#x2F;示例：\nlocalStorage.removeItem(&#39;name&#39;)\nlocalStorage.getItem(&#39;name&#39;) &#x2F;&#x2F; null\n\n删除 key 为 name 的数据后，loaclStorage 里已经获取不到该数据，则返回 null。\nclear删除所有数据：localStorage.clear();\n&#x2F;&#x2F;示例：\nlocalStorage.clear()\n\n此时会把 localStorage 中的所有数据都删除。\nkey得到某个索引的 key：localStorage.key(index);\n&#x2F;&#x2F;示例：\nlocalStorage.setItem(&#39;name1&#39;, &#39;Hello World&#39;)\nlocalStorage.setItem(&#39;name2&#39;, &#39;Hello Linxin&#39;)\nlocalStorage.key(1) &#x2F;&#x2F; name2\n\n获取到索引为 1 的 key，即 name2。\n构造函数在实际项目中，可能需要多次对 localStorage 进行操作，我们可以通过一个构造函数来更好的操作。\n&#x2F;&#x2F;示例：\nvar localEvent &#x3D; function (item) &#123;\n  this.get &#x3D; function () &#123;\n    return localStorage.getItem(item)\n  &#125;\n  this.set &#x3D; function (val) &#123;\n    localStorage.setItem(item, val)\n  &#125;\n  this.remove &#x3D; function () &#123;\n    localStorage.removeItem(item)\n  &#125;\n  this.clear &#x3D; function () &#123;\n    localStorage.clear()\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用new字符把构造函数实例化出多个对象\nvar local1 &#x3D; new localEvent(&#39;name1&#39;)\nvar local2 &#x3D; new localEvent(&#39;name2&#39;)\n\nlocal1.set(&#39;Hello World&#39;)\nlocal2.set(&#39;Hello Linxin&#39;)\n\nlocal1.get() &#x2F;&#x2F; Hello World\nlocal2.get() &#x2F;&#x2F; Hello Linxin\n\n这里只是简单的演示，像我们平时在项目中可能要把对象存储起来，就需要在代码里做些处理。\n监听 storage 事件可以通过监听 window 对象的 storage 事件并指定其事件处理函数，当页面中对 localStorage 或 sessionStorage 进行修改时，则会触发对应的处理函数。\nwindow.addEventListener(&#39;storage&#39;, function (e) &#123;\n  console.log(&#39;key&#x3D;&#39; + e.key + &#39;,oldValue&#x3D;&#39; + e.oldValue + &#39;,newValue&#x3D;&#39; + e.newValue)\n&#125;)\n\n触发事件的时间对象（e 参数值）有几个属性：\n\nkey : 键值。\noldValue : 被修改前的值。\nnewValue : 被修改后的值。\nurl : 页面 url。\nstorageArea : 被修改的 storage 对象。\n\n注意：在谷歌浏览器中，需要在不同标签页中修改 storage 才会触发该事件，即 网页 A 监听该事件，在 网页 B 中修改 localStorage，则 网页 A 会触发事件函数。但是在 IE 中，在同个网页修改 localStorage 都会触发该事件。\n调试谷歌浏览器自带调试工具(chrome devtools)非常好用，可以用来调试 localStorage 和 sessionStorage。打开浏览器按 f12 调出调试工具，可以看到 Application ，点击打开可以看到左边栏有 Storage，包括了 localStorage、sessionStorage、IndexedDB 等，选中我们要调试的网站域名，可以看到右边有对应的 key 和 value，可以通过右键进行编辑或删除等。\n","slug":"Web Storage - HTML5本地存储","date":"2018-06-06T02:11:34.000Z","categories_index":"Web Storage","tags_index":"Web Storage","author_index":"Bobby's Blog"},{"id":"da5ae32f197a713b14ae5cac1efd5d4a","title":"JS判断浏览器类型总结","content":"开发 APP 过程中，需要打包上线 APP。为了用户体验好，我们新增了一个静态下载页面。用户扫描二维码进入到我们的下载页面，但是很多情况是推送给客户，客户可能会在微信或者 QQ 中打开我们的下载页面，点击下载按钮时无法实现下载我们的 APP，所以需要对用户打开下载页面进行判断，下面就是我们需要的判断代码：\nJS 获取浏览器信息浏览器代码名称：navigator.appCodeName浏览器名称：navigator.appName浏览器版本号：navigator.appVersion对 Java 的支持：navigator.javaEnabled()MIME 类型（数组）：navigator.mimeTypes系统平台：navigator.platform插件（数组）：navigator.plugins用户代理：navigator.userAgent\n\n\nJS 判断是否是移动端（Mobile）、ipad、iphone、微信、QQ 等var browser &#x3D; &#123;\n  versions: (function () &#123;\n    var u &#x3D; navigator.userAgent,\n      app &#x3D; navigator.appVersion\n    return &#123;\n      trident: u.indexOf(&#39;Trident&#39;) &gt; -1, &#x2F;&#x2F;IE内核\n      presto: u.indexOf(&#39;Presto&#39;) &gt; -1, &#x2F;&#x2F;opera内核\n      webKit: u.indexOf(&#39;AppleWebKit&#39;) &gt; -1, &#x2F;&#x2F;苹果、谷歌内核\n      gecko: u.indexOf(&#39;Gecko&#39;) &gt; -1 &amp;&amp; u.indexOf(&#39;KHTML&#39;) &#x3D;&#x3D; -1, &#x2F;&#x2F;火狐内核\n      mobile: !!u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;), &#x2F;&#x2F;是否为移动终端\n      ios: !!u.match(&#x2F;\\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;), &#x2F;&#x2F;ios终端\n      android: u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1, &#x2F;&#x2F;android终端或者uc浏览器\n      iPhone: u.indexOf(&#39;iPhone&#39;) &gt; -1, &#x2F;&#x2F;是否为iPhone或者QQHD浏览器\n      iPad: u.indexOf(&#39;iPad&#39;) &gt; -1, &#x2F;&#x2F;是否iPad\n      wp: u.toLowerCase().indexOf(&#39;windows phone&#39;) &gt; -1, &#x2F;&#x2F;是否为wp手机\n      webApp: u.indexOf(&#39;Safari&#39;) &#x3D;&#x3D; -1, &#x2F;&#x2F;是否web应该程序，没有头部与底部\n      weixin: u.indexOf(&#39;MicroMessenger&#39;) &gt; -1, &#x2F;&#x2F;是否微信\n      qq: u.match(&#x2F;\\sQQ&#x2F;i) &#x3D;&#x3D; &#39; qq&#39;, &#x2F;&#x2F;是否QQ\n    &#125;\n  &#125;)(),\n  language: (navigator.browserLanguage || navigator.language).toLowerCase(),\n&#125;\n\n&#x2F;&#x2F;判断是否IE内核\nif (browser.versions.trident) &#123;\n  alert(&#39;is IE&#39;)\n&#125;\n&#x2F;&#x2F;判断是否webKit内核\nif (browser.versions.webKit) &#123;\n  alert(&#39;is webKit&#39;)\n&#125;\n&#x2F;&#x2F;判断是否移动端\nif (browser.versions.mobile || browser.versions.android || browser.versions.ios) &#123;\n  alert(&#39;移动端&#39;)\n&#125;\n\nJS 判断浏览器和手机类型汇总(function getUA(window) &#123;\n    var ua     &#x3D; navigator.userAgent.toLowerCase();\n    var ieMode &#x3D; document.documentMode,\n        isIE   &#x3D; !!window.ActiveXObject,\n        isIE6  &#x3D; isIE &amp;&amp; !window.XMLHttpRequest;\n    var isEdge&#x3D;&#x2F;edge&#x2F;i.test(ua),\n        isOpera&#x3D;&#x2F;opr&#x2F;i.test(ua);\n    var isIpad &#x3D; &#x2F;(ipad).*os\\s([\\d_]+)&#x2F;i.test(ua);\n\n    window.UA &#x3D; &#123;\n        isMobile    : &#x2F;applewebkit.*mobile.*&#x2F;.test(ua) || &#x2F;applewebKit&#x2F;.test(ua),                           &#x2F;&#x2F;是否为移动端\n        isMac       : &#x2F;mac os x&#x2F;.test(ua),                                                                  &#x2F;&#x2F;苹果电脑\n        isAndroid   : ua.indexOf(&#39;android&#39;) &gt; -1 || ua.indexOf(&#39;linux&#39;) &gt; -1,                               &#x2F;&#x2F;android终端\n        isIPhone    : !isIpad &amp;&amp; &#x2F;(iphone\\sos)\\s([\\d_]+)&#x2F;i.test(ua),                                        &#x2F;&#x2F;iphone\n        isIPad      : isIpad,                                                                               &#x2F;&#x2F;ipad\n        isIos       : isIpad || &#x2F;(iphone\\sos)\\s([\\d_]+)&#x2F;i.test(ua),                                         &#x2F;&#x2F;ios系统,包括ipad和iphone；(不包含iPod touch)\n        isWeiXin    : &#x2F;micromessenger&#x2F;i.test(ua),                                                           &#x2F;&#x2F;weixin\n        isUC        : ua.indexOf(&#39;ucbrowser&#39;) &gt; -1,                                                         &#x2F;&#x2F;UC\n        isUC_Webkit : &#x2F;uc\\sapplewebkit\\&#x2F;([\\d.]+)&#x2F;i.test(ua),                                                &#x2F;&#x2F;isUC_Webkit\n        isUC_Proxy  : &#x2F;(ucweb)(\\d.+?(?&#x3D;\\&#x2F;))&#x2F;i.test(ua),                                                     &#x2F;&#x2F;isUC_Proxy\n\n        isWeibo     : &#x2F;weibo&#x2F;i.test(ua),                                                                    &#x2F;&#x2F;在新浪微博客户端打开\n        isQQ        : &#x2F;(qq)\\&#x2F;&#x2F;i.test(ua),                                                                   &#x2F;&#x2F;在QQ\n        isChrome    : (&#x2F;chrome\\&#x2F;([\\d.]+)&#x2F;.test(ua) || &#x2F;crios\\&#x2F;([\\d.]+)&#x2F;.test(ua))&amp;&amp; !isEdge &amp;&amp; !isOpera,    &#x2F;&#x2F;Chrome\n        isMozilla   : ua.indexOf(&#39;gecko&#39;) &gt; -1 &amp;&amp; ua.indexOf(&#39;khtml&#39;) &#x3D;&#x3D; -1,                                &#x2F;&#x2F;火狐内核\n        isWebkit    : &#x2F;applewebkit&#x2F;i.test(ua),                                                              &#x2F;&#x2F;苹果，谷歌内核\n        isOpera     : isOpera,                                                                              &#x2F;&#x2F;opera浏览器，webkit\n        isSafari    : &#x2F;safari&#x2F;i.test(ua) &amp;&amp; (!&#x2F;chrome&#x2F;i.test(ua)),                                          &#x2F;&#x2F;苹果浏览器\n        isBlackberry: &#x2F;(blackberry).*version\\&#x2F;([\\d.]+)&#x2F;i.test(ua),                                          &#x2F;&#x2F;blackberry\n\n\n        isEdge      : isEdge,                                                                               &#x2F;&#x2F;edge\n        isIE        : isIE,                                                                                 &#x2F;&#x2F;IE\n        isIE6       : isIE6,                                                                                &#x2F;&#x2F;IE6\n        isIE7       : isIE &amp;&amp; !isIE6 &amp;&amp; !ieMode || ieMode &#x3D;&#x3D; 7,                                             &#x2F;&#x2F;IE7\n        isIE8       : isIE &amp;&amp; ieMode &#x3D;&#x3D; 8,                                                                  &#x2F;&#x2F;IE8\n        isIE9       : isIE &amp;&amp; ieMode &#x3D;&#x3D; 9,                                                                  &#x2F;&#x2F;IE9\n        isIE10      : isIE &amp;&amp; ieMode &#x3D;&#x3D; 10,                                                                 &#x2F;&#x2F;IE10\n\n        is360mse    : &#x2F;360 aphone browser|qhbrowser&#x2F;i.test(ua),                                             &#x2F;&#x2F;360手机浏览器\n\n        isHorizontal: window.orientation &#x3D;&#x3D; 90 || window.orientation &#x3D;&#x3D; -90,                                &#x2F;&#x2F;是否横屏\n        isVertical  : window.orientation &#x3D;&#x3D; 0 || window.orientation &#x3D;&#x3D; 180                                  &#x2F;&#x2F;是否竖屏\n    &#125;\n&#125;)(window);\n\neq：\nif(UA.isWeiXin)&#123;\n    console.log(&quot;现在是微信打开&quot;);\n&#125;else  if(UA.isChrome)&#123;\n    console.log(&quot;现在是Chrome打开&quot;);\n&#125;else&#123;\n    console.log(&quot;other&quot;);\n&#125;\n\nJS 判断客户端是否是 iOS 或者 Android 手机移动端,跳转到不同页面if (&#x2F;(iPhone|iPad|iPod|iOS)&#x2F;i.test(navigator.userAgent)) &#123;\n  &#x2F;&#x2F;alert(navigator.userAgent);\n  window.location.href &#x3D; &#39;iPhone.html&#39;\n&#125; else if (&#x2F;(Android)&#x2F;i.test(navigator.userAgent)) &#123;\n  &#x2F;&#x2F;alert(navigator.userAgent);\n  window.location.href &#x3D; &#39;Android.html&#39;\n&#125; else &#123;\n  window.location.href &#x3D; &#39;pc.html&#39;\n&#125;\n\nJS 微信客户端判断var ua &#x3D; navigator.userAgent.toLowerCase()\nvar isWeixin &#x3D; ua.indexOf(&#39;micromessenger&#39;) !&#x3D; -1\nvar isAndroid &#x3D; ua.indexOf(&#39;android&#39;) !&#x3D; -1\nvar isIos &#x3D; ua.indexOf(&#39;iphone&#39;) !&#x3D; -1 || ua.indexOf(&#39;ipad&#39;) !&#x3D; -1\nif (!isWeixin) &#123;\n  document.head.innerHTML &#x3D;\n    &#39;&lt;title&gt;抱歉，出错了&lt;&#x2F;title&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, user-scalable&#x3D;0&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;https:&#x2F;&#x2F;res.wx.qq.com&#x2F;open&#x2F;libs&#x2F;weui&#x2F;0.4.1&#x2F;weui.css&quot;&gt;&#39;\n  document.body.innerHTML &#x3D;\n    &#39;&lt;div class&#x3D;&quot;weui_msg&quot;&gt;&lt;div class&#x3D;&quot;weui_icon_area&quot;&gt;&lt;i class&#x3D;&quot;weui_icon_info weui_icon_msg&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;weui_text_area&quot;&gt;&lt;h4 class&#x3D;&quot;weui_msg_title&quot;&gt;请在微信客户端打开链接&lt;&#x2F;h4&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#39;\n&#125;\n","slug":"JS判断浏览器类型","date":"2018-05-13T12:13:15.000Z","categories_index":"Browser","tags_index":"Browser JS","author_index":"Bobby's Blog"},{"id":"58c3765b4ca8e3bdf0eac83cf4cb3ffa","title":"Ajax解析","content":"AJAX 即“Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。Ajax 不是一种新的编程语言，而是使用现有标准的新方法。AJAX 可以在不重新加载整个页面的情况下，与服务器交换数据。这种异步交互的方式，使用户单击后，不必刷新页面也能获取新数据。使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。\n\n\nAjax 中的对象和方法说明Ajax 的核心对象就是 xmlHttpRequest,用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n1.方法xmlHttpRequst 对象利用 send()和 open()方法与服务器进行交互。open(method,url,async)　　 method：请求的类型；GET 或 POST　　 url：文件在服务器上的位置　　 async：true（异步）或 false（同步）send(string)　　 string：仅用于 POST 请求如果是 post 请求，必须使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中设置发送的数据：\nxmlhttp.open(&#39;POST&#39;, &#39;test.php&#39;, true)\nxmlhttp.setRequestHeader(&#39;Content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;)\nxmlhttp.send(&#39;fname&#x3D;Bill&amp;lname&#x3D;Gates&#39;)\n\n2.属性readyState　　 0: 请求未初始化　　 1: 服务器连接已建立　　 2: 请求已接收　　 3: 请求处理中　　 4: 请求已完成，且响应已就绪State　　 200: “OK”　　 404: 未找到页面responseText　　获得字符串形式的响应数据。responseXML　　获得 XML 形式的响应数据。onreadystatechange　　存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。\n3.运行原理ajax 通过 xmlhttpRequest 对象执行操作，其中 xmlhttpRequest 对象是在浏览器中内置的一个对象，其运行原理就相当于创建了一个请求代理，通过代理去完成与服务器的交互，交互的过程中客户不需要等待，还可以进行其它的工作，交互完成以后，代理再将交互的结果返回给客户页面。\n第一步：创建 xmlHttpRequest 对象，每个浏览器的创建不是都相同。　　　　常情况下为了兼容所有浏览器，每个都要写上。第二步：设置 open()方法和 setRequestHeader()方法参数。　　　　将请求方式，请求目的地址，和请求类型设置到 open 方法中，如果是 post 请求，则需要设置 setRequestHeader()参数第三步：发送执行　　　　利用 send 方法，与服务器真正的交互执行第四步：获得执行结果　　　　首先判断执行是否完成，然后通过 js 操作 dom 元素，将返回的 responseText 返回到页面\nvar xmlHttp &#x2F;&#x2F;声明xmlHttp对象\n&#x2F;&#x2F;实例化xmlHttpRequest对象\nfunction createXMLHttpRequest() &#123;\n  if (window.XMLHttpRequest) &#123;\n    xmlHttp &#x3D; new XMLHttpRequest()\n  &#125; else if (window.ActiveXObject) &#123;\n    xmlHttp &#x3D; new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)\n  &#125;\n&#125;\n&#x2F;&#x2F;input失去焦点事件onblur()，调用这个js方法验证\nfunction validate(field) &#123;\n  if (trim(field.value).length !&#x3D; 0) &#123;\n    &#x2F;&#x2F;创建XMLHttpRequest\n    createXMLHttpRequest()\n    &#x2F;&#x2F;每次请求的url地址不同，利用时间产生不同url地址，可以防止缓冲造成问题\n    var url &#x3D; &#39;user_validate.php?userId&#x3D;&#39; + trim(field.value) + &#39;×tamp&#x3D;&#39; + new Date().getTime()\n    xmlHttp.open(&#39;GET&#39;, url, true)\n    &#x2F;&#x2F;方法地址，处理完成后自动调用，回调\n    xmlHttp.onreadystatechange &#x3D; function () &#123;\n      &#x2F;&#x2F;匿名函数\n      if (xmlHttp.readyState &#x3D;&#x3D; 4) &#123;\n        &#x2F;&#x2F;Ajax引擎初始化成功\n        if (xmlHttp.status &#x3D;&#x3D; 200) &#123;\n          &#x2F;&#x2F;http协议成功\n          document.getElementById(&#39;myDiv&#39;).innerHTML &#x3D; xmlhttp.responseText\n        &#125; else &#123;\n          alert(&#39;请求失败，错误码&#x3D;&#39; + xmlHttp.status)\n        &#125;\n      &#125;\n    &#125;\n    &#x2F;&#x2F;将参数发送到Ajax引擎\n    xmlHttp.send(null)\n  &#125; else &#123;\n    document.getElementById(&#39;myDiv&#39;).innerHTML &#x3D; &#39;&#39;\n  &#125;\n&#125;\n\n$.ajax()方法详解1.url:要求为 String 类型的参数，（默认为当前页地址）发送请求的地址。\n2.type:要求为 String 类型的参数，请求方式（post 或 get）默认为 get。注意其他 http 请求方法，例如 put 和 delete 也可以使用，但仅部分浏览器支持。\n3.timeout:要求为 Number 类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。\n4.async:要求为 Boolean 类型的参数，默认设置为 true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\n5.cache:要求为 Boolean 类型的参数，默认为 true（当 dataType 为 script 时，默认为 false），设置为 false 将不会从浏览器缓存中加载请求信息。\n6.data:要求为 Object 或 String 类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get 请求中将附加在 url 后。防止这种自动转换，可以查看 processData 选项。对象必须为 key/value 格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery 将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。\n7.dataType:要求为 String 类型的参数，预期服务器返回的数据类型。如果不指定，JQuery 将自动根据 http 包 mime 信息返回 responseXML 或 responseText，并作为回调函数参数传递。可用的类型如下：xml：返回 XML 文档，可用 JQuery 处理。html：返回纯文本 HTML 信息；包含的 script 标签会在插入 DOM 时执行。script：返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 cache 参数。注意在远程请求时（不在同一个域下），所有 post 请求都将转为 get 请求。json：返回 JSON 数据。jsonp：JSONP 格式。使用 SONP 形式调用函数时，例如 myurl?callback=?，JQuery 将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。\n8.beforeSend：要求为 Function 类型的参数，发送请求前可以修改 XMLHttpRequest 对象的函数，例如添加自定义 HTTP 头。在 beforeSend 中如果返回 false 可以取消本次 ajax 请求。XMLHttpRequest 对象是惟一的参数。　　 function(XMLHttpRequest){　　　　 this; //调用本次 ajax 请求时传递的 options 参数　　}\n9.complete：要求为 Function 类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest 对象和一个描述成功请求类型的字符串。　　 function(XMLHttpRequest, textStatus){　　　　 this; //调用本次 ajax 请求时传递的 options 参数　　}\n10.success：要求为 Function 类型的参数，请求成功后调用的回调函数，有两个参数。　　(1)由服务器返回，并根据 dataType 参数进行处理后的数据。　　(2)描述状态的字符串。　　 function(data, textStatus){　　　　//data 可能是 xmlDoc、jsonObj、html、text 等等　　　　 this; //调用本次 ajax 请求时传递的 options 参数　　}\n11.error:要求为 Function 类型的参数，请求失败时被调用的函数。该函数有 3 个参数，即 XMLHttpRequest 对象、错误信息、捕获的错误对象(可选)。ajax 事件函数如下：　　 function(XMLHttpRequest, textStatus, errorThrown){　　　　//通常情况下 textStatus 和 errorThrown 只有其中一个包含信息　　　　 this; //调用本次 ajax 请求时传递的 options 参数　　}\n12.contentType：要求为 String 类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。\n13.dataFilter：要求为 Function 类型的参数，给 Ajax 返回的原始数据进行预处理的函数。提供 data 和 type 两个参数。data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。　　 function(data, type){　　　　//返回处理后的数据　　　　 return data;　　}\n14.dataFilter：要求为 Function 类型的参数，给 Ajax 返回的原始数据进行预处理的函数。提供 data 和 type 两个参数。data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。　　 function(data, type){　　　　//返回处理后的数据　　　　 return data;　　}\n15.global：要求为 Boolean 类型的参数，默认为 true。表示是否触发全局 ajax 事件。设置为 false 将不会触发全局 ajax 事件，ajaxStart 或 ajaxStop 可用于控制各种 ajax 事件。\n16.ifModified：要求为 Boolean 类型的参数，默认为 false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是 Last-Modified 头信息。默认值是 false，即忽略头信息。\n17.jsonp：要求为 String 类型的参数，在一个 jsonp 请求中重写回调函数的名字。该值用来替代在”callback=?”这种 GET 或 POST 请求中 URL 参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。\n18.username：要求为 String 类型的参数，用于响应 HTTP 访问认证请求的用户名。\n19.password：要求为 String 类型的参数，用于响应 HTTP 访问认证请求的密码。\n20.processData：要求为 Boolean 类型的参数，默认为 true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送 DOM 树信息或者其他不希望转换的信息，请设置为 false。\n21.scriptCharset：要求为 String 类型的参数，只有当请求时 dataType 为”jsonp”或者”script”，并且 type 是 GET 时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。\n1. jQuery.get(...)\n       所有参数：\n              url: 待载入页面的URL地址\n             data: 待发送 Key&#x2F;value 参数。\n          success: 载入成功时回调函数。\n         dataType: 返回内容格式，xml, json,  script, text, html\n\n2.jQuery.post(...)\n       所有参数：\n              url: 待载入页面的URL地址\n             data: 待发送 Key&#x2F;value 参数\n          success: 载入成功时回调函数\n         dataType: 返回内容格式，xml, json,  script, text, html\n\n3.jQuery.getJSON(...)\n       所有参数：\n              url: 待载入页面的URL地址\n             data: 待发送 Key&#x2F;value 参数。\n          success: 载入成功时回调函数。\n\n4.jQuery.getScript(...)\n       所有参数：\n              url: 待载入页面的URL地址\n             data: 待发送 Key&#x2F;value 参数。\n          success: 载入成功时回调函数。\n\n5.jQuery.ajax(...)\n       部分参数：\n              url：请求地址\n             type：请求方式，GET、POST（1.9.0之后用method）\n          headers：请求头\n             data：要发送的数据\n      contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)\n            async：是否异步\n          timeout：设置请求超时时间（毫秒）\n       beforeSend：发送请求前执行的函数(全局)\n         complete：完成之后执行的回调函数(全局)\n          success：成功之后执行的回调函数(全局)\n            error：失败之后执行的回调函数(全局)\n          accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型\n         dataType：将服务器端返回的数据转换成指定类型\n            &quot;xml&quot;: 将服务器端返回的内容转换成xml格式\n           &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式\n           &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n         &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式\n           &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象\n          &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n","slug":"Ajax解析","date":"2018-05-11T11:56:04.000Z","categories_index":"Ajax","tags_index":"Ajax","author_index":"Bobby's Blog"},{"id":"018a5cfaa025f44d4ca2309411ae5700","title":"Vim 常用快捷键","content":"对 Vim 的大名早就如雷贯耳，更加如雷贯耳的是 Vim 在各种大神眼中的地位——coding 神器。对于新手 coding,工欲善其事必先利其器,这里本着最简单快速上手的原则给出一些最最有用的快捷键,通过这些就不觉得 vim 有多难用了。\n\n\n\n基本操作\n\n\n快捷键\n功能\n\n\n\nEsc\n从当前模式转换到“普通模式”。所有的键对应到命令。\n\n\ni\n“插入模式”用于插入文字。回归按键的本职工作。\n\n\n:\n“命令行模式” Vim 希望你输入类似于保存该文档命令的地方。\n\n\n保存并退出\n\n\n快捷键\n功能\n\n\n\n:q\n退出 Vim，如果文件已被修改，将退出失败\n\n\n:w\n保存文件\n\n\n:w\nnew_name 用 new_name 作为文件名保存文件\n\n\n:wq\n保存文件并退出 Vim\n\n\n:q!\n退出 Vim，不保存文件改动\n\n\nZZ\n退出 Vim，如果文件被改动过，保存改动内容\n\n\nZQ\n与 :q! 相同，退出 Vim，不保存文件改动\n\n\n方向键\n\n\n快捷键\n功能\n\n\n\nh\n光标向左移动一个字符\n\n\nj\n或 Ctrl + J 光标向下移动一行\n\n\nk\n或 Ctrl + P 光标向上移动一行\n\n\nl\n光标向右移动一个字符\n\n\n0\n（数字 0）移动光标至本行开头\n\n\n$\n移动光标至本行末尾\n\n\n^\n移动光标至本行第一个非空字符处\n\n\nw\n向前移动一个词 （上一个字母和数字组成的词之后）\n\n\nW\n向前移动一个词 （以空格分隔的词）\n\n\n5w\n向前移动五个词\n\n\nb\n向后移动一个词 （下一个字母和数字组成的词之前）\n\n\nB\n向后移动一个词 （以空格分隔的词）\n\n\n5b\n向后移动五个词\n\n\nG\n移动至文件末尾\n\n\ngg\n移动至文件开头\n\n\n浏览文档\n\n\n快捷键\n功能\n\n\n\n(\n跳转到上一句\n\n\n)\n跳转到下一句\n\n\n{\n跳转到上一段\n\n\n}\n跳转到下一段\n\n\n[[\n跳转到上一部分\n\n\n]]\n跳转到下一部分\n\n\n[]\n跳转到上一部分的末尾\n\n\n][\n跳转到上一部分的开头\n\n\n插入文本\n\n\n快捷键\n功能\n\n\n\na\n在光标后插入文本\n\n\nA\n在行末插入文本\n\n\ni\n在光标前插入文本\n\n\no\n（小写字母 o）在光标下方新开一行\n\n\nO\n（大写字母 O）在光标上方新开一行\n\n\n特殊插入\n\n\n快捷键\n功能\n\n\n\n:r\n[filename] 在光标下方插入文件 [filename] 的内容\n\n\n:r\n![command] 执行命令 [command] ，并将输出插入至光标下方\n\n\n删除文本\n\n\n快捷键\n功能\n\n\n\nx\n删除光标处字符\n\n\ndw\n删除一个词\n\n\nd0\n删至行首\n\n\nd$\n删至行末\n\n\nd)\n删至句末\n\n\ndgg\n删至文件开头\n\n\ndG\n删至文件末尾\n\n\ndd\n删除该行\n\n\n3dd\n删除三行\n\n\n简单替换文本\n\n\n快捷键\n功能\n\n\n\nr{text}\n将光标处的字符替换成 {text}\n\n\nR\n进入覆写模式，输入的字符将替换原有的字符\n\n\n复制/粘贴文本\n\n\n快捷键\n功能\n\n\n\nyy\n复制当前行至存储缓冲区\n\n\n[“x]yy\n复制当前行至寄存器 x\n\n\np\n在当前行之后粘贴存储缓冲区中的内容\n\n\nP\n在当前行之前粘贴存储缓冲区中的内容\n\n\n[“x]p\n在当前行之后粘贴寄存器 x 中的内容\n\n\n[“x]P\n在当前行之前粘贴寄存器 x 中的内容\n\n\n撤销/重做操作\n\n\n快捷键\n功能\n\n\n\nu\n撤销最后的操作\n\n\nCtrl+r\n重做最后撤销的操作\n\n\n搜索和替换\n\n\n快捷键\n功能\n\n\n\n/search_text\n检索文档，在文档后面的部分搜索 search_text\n\n\n?search_text\n检索文档，在文档前面的部分搜索 search_text\n\n\nn\n移动到后一个检索结果\n\n\nN\n移动到前一个检索结果\n\n\n:%s/original/replacement\n检索第一个 “original” 字符串并将其替换成 “replacement”\n\n\n:%s/original/replacement/g\n检索并将所有的 “original” 替换为 “replacement”\n\n\n:%s/original/replacement/gc\n检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换\n\n\n书签\n\n\n快捷键\n功能\n\n\n\nm {a-zA-Z}\n在当前光标位置设置书签，书签名可用一个大小写字母（{a-zA-Z}）\n\n\n:marks\n列出所有书签\n\n\n{a-zA-Z}\n跳转到书签 {a-zA-Z}\n\n\n选择文本\n\n\n快捷键\n功能\n\n\n\nv\n进入逐字可视模式\n\n\nV\n进入逐行可视模式\n\n\nEsc\n退出可视模式\n\n\n改动选中文本\n\n\n快捷键\n功能\n\n\n\n~\n切换大小写\n\n\nd\n删除一个词\n\n\nc\n变更\n\n\ny\n复制\n\n\n&gt;\n右移\n\n\n&lt;\n左移\n\n\n!\n通过外部命令进行过滤\n\n\n","slug":"Vim 快捷键","date":"2018-04-15T06:20:33.000Z","categories_index":"Vim","tags_index":"Vim","author_index":"Bobby's Blog"},{"id":"3b78bce7f2113b64e362b98a91c69f3f","title":"VSCode常用快捷键与插件","content":"Visual Studio Code（VS Code）是一个由微软开发的，同时支持 Windows、Linux 和 macOS 操作系统的开源文本编辑器。它支持调试，内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段、代码重构等。该编辑器支持用户自定义配置，例如改变主题颜色、键盘快捷方式、编辑器属性和其他参数，还支持扩展程序并在编辑器中内置了扩展程序管理的功能。官网下载地址： https://code.visualstudio.com/。\n\n\n常规\n\n\n快捷键\n作用\n\n\n\nctrl + shift + P\n打开命令行面板\n\n\nctrl+ P\n快速打开文件\n\n\nctrl + shift + N\n新建编辑窗口\n\n\nctrl + shift + W\n关闭当前编辑窗口\n\n\n基础编辑\n\n\n快捷键\n作用\n\n\n\nCtrl + X\n剪切\n\n\nCtrl + C\n复制\n\n\nAlt + up/down\n移动行上下\n\n\nShift + Alt up/down\n在当前行上下复制当前行\n\n\nCtrl + Shift + K\n删除行\n\n\nCtrl + Enter\n在当前行下插入新的一行\n\n\nCtrl + Shift + Enter\n在当前行上插入新的一行\n\n\nCtrl + Shift + I\n匹配花括号的闭合处，跳转\n\n\nCtrl + ] / [\n行缩进\n\n\nHome\n光标跳转到行头\n\n\nEnd\n光标跳转到行尾\n\n\nCtrl + Home\n跳转到页头\n\n\nCtrl + End\n跳转到页尾\n\n\nCtrl + up/down\n行视图上下偏移\n\n\nAlt + PgUp/PgDown\n屏视图上下偏移\n\n\nCtrl + Shift + [\n折叠区域代码\n\n\nCtrl + Shift + ]\n展开区域代码\n\n\nCtrl + K Ctrl + [\n折叠所有子区域代码\n\n\nCtrl + k Ctrl + ]\n展开所有折叠的子区域代码\n\n\nCtrl + K Ctrl + 0\n折叠所有区域代码\n\n\nCtrl + K Ctrl + J\n展开所有折叠区域代码\n\n\nCtrl + K Ctrl + C\n添加行注释\n\n\nCtrl + K Ctrl + U\n删除行注释\n\n\nCtrl + /\n添加关闭行注释\n\n\nShift + Alt +A\n块区域注释\n\n\nAlt + Z\n添加关闭词汇包含\n\n\n导航\n\n\n快捷键\n作用\n\n\n\nCtrl + T\n列出所有符号\n\n\nCtrl + G\n跳转行\n\n\nCtrl + P\n跳转文件\n\n\nCtrl + Shift + O\n跳转到符号处\n\n\nCtrl + Shift + M\n打开问题展示面板\n\n\nF8\n跳转到下一个错误或者警告\n\n\nShift + F8\n跳转到上一个错误或者警告\n\n\nCtrl + Shift + Tab\n切换到最近打开的文件\n\n\nAlt + left / right\n向后、向前\n\n\nCtrl + M\n进入用 Tab 来移动焦点\n\n\n查询与替换\n\n\n快捷键\n作用\n\n\n\nCtrl + F\n查询\n\n\nCtrl + H\n替换\n\n\nF3 / Shift + F3\n查询下一个/上一个\n\n\nAlt + Enter\n选中所有出现在查询中的\n\n\nCtrl + D\n匹配当前选中的词汇或者行，再次选中-可操作\n\n\nCtrl + K Ctrl + D\n移动当前选择到下个匹配选择的位置(光标选定)\n\n\n多行光标操作于选择\n\n\n快捷键\n作用\n\n\n\nAlt + Click\n插入光标-支持多个\n\n\nCtrl + Alt + up/down\n上下插入光标-支持多个\n\n\nCtrl + U\n撤销最后一次光标操作\n\n\nShift + Alt + I\n插入光标到选中范围内所有行结束符\n\n\nCtrl + I\n选中当前行\n\n\nCtrl + Shift + L\n选择所有出现在当前选中的行-操作\n\n\nCtrl + F2\n选择所有出现在当前选中的词汇-操作\n\n\nShift + Alt + right\n从光标处扩展选中全行\n\n\nShift + Alt + left\n收缩选择区域\n\n\nShift + Alt + (drag mouse)\n鼠标拖动区域，同时在多个行结束符插入光标\n\n\nCtrl + Shift + Alt + (Arrow Key)\n也是插入多行光标的[方向键控制]\n\n\nCtrl + Shift + Alt + PgUp/PgDown\n也是插入多行光标的[整屏生效]\n\n\n丰富的语言操作\n\n\n快捷键\n作用\n\n\n\nCtrl + Space\n输入建议[智能提示]\n\n\nCtrl + Shift + Space\n参数提示\n\n\nTab\nEmmet 指令触发/缩进\n\n\nShift + Alt + F\n格式化代码\n\n\nCtrl + K Ctrl + F\n格式化选中部分的代码\n\n\nF12\n跳转到定义处\n\n\nAlt + F12\n代码片段显示定义\n\n\nCtrl + K F12\n在其他窗口打开定义处\n\n\nCtrl + .\n快速修复部分可以修复的语法错误\n\n\nShift + F12\n显示所有引用\n\n\nF2\n重命名符号\n\n\nCtrl + Shift + . /\n替换下个值\n\n\nCtrl + K Ctrl + X\n移除空白字符\n\n\nCtrl + K M\n更改页面文档格式\n\n\n编辑器管理\n\n\n快捷键\n作用\n\n\n\nCtrl + F4, Ctrl + W\n关闭编辑器\n\n\nCtrl + k F\n关闭当前打开的文件夹\n\n\nCtrl + I\n切割编辑窗口\n\n\nCtrl + 1/2/3\n切换焦点在不同的切割窗口\n\n\nCtrl + K Ctrl &lt;-/-&gt;\n切换焦点在不同的切割窗口\n\n\nCtrl + Shift + PgUp/PgDown\n切换标签页的位置\n\n\nCtrl + K &lt;-/-&gt;\n切割窗口位置调换\n\n\n文件管理\n\n\n快捷键\n作用\n\n\n\nCtrl + N\n新建文件\n\n\nCtrl + O\n打开文件\n\n\nCtrl + S\n保存文件\n\n\nCtrl + Shift + S\n另存为\n\n\nCtrl + K S\n保存所有当前已经打开的文件\n\n\nCtrl + F4\n关闭当前编辑窗口\n\n\nCtrl + K Ctrl + W\n关闭所有编辑窗口\n\n\nCtrl + Shift + T\n撤销最近关闭的一个文件编辑窗口\n\n\nCtrl + K Enter\n保持开启\n\n\nCtrl + Shift + Tab\n调出最近打开的文件列表，重复按会切换\n\n\nCtrl + Tab\n与上面一致，顺序不一致\n\n\nCtrl + K P\n复制当前打开文件的存放路径\n\n\nCtrl + K R\n打开当前编辑文件存放位置【文件管理器】\n\n\nCtrl + K O\n在新的编辑器中打开当前编辑的文件\n\n\n显示\n\n\n快捷键\n作用\n\n\n\nF11\n切换全屏模式\n\n\nShift + Alt + 1\n切换编辑布局【目前无效】\n\n\nCtrl + =/-\n放大 / 缩小\n\n\nCtrl + B\n侧边栏显示隐藏\n\n\nCtrl + Shift + E\n资源视图和编辑视图的焦点切换\n\n\nCtrl + Shift + F\n打开全局搜索\n\n\nCtrl + Shift + G\n打开 Git 可视管理\n\n\nCtrl + Shift + D\n打开 DeBug 面板\n\n\nCtrl + Shift + X\n打开插件市场面板\n\n\nCtrl + Shift + H\n在当前文件替换查询替换\n\n\nCtrl + Shift + J\n开启详细查询\n\n\nCtrl + Shift + V\n预览 Markdown 文件【编译后】\n\n\nCtrl + K v\n在边栏打开渲染后的视图【新建】\n\n\n调试\n\n\n快捷键\n作用\n\n\n\nF5\n启动调试、继续\n\n\nF11 / Shift + F11\n单步进入 / 单步跳出\n\n\nF10\n单步跳过\n\n\nCtrl + K Ctrl + I\n显示悬浮\n\n\n集成终端\n\n\n快捷键\n作用\n\n\n\nCtrl + `\n打开集成终端\n\n\nCtrl + Shift + `\n创建一个新的终端\n\n\nCtrl + Shift + C\n复制所选\n\n\nCtrl + Shift + V\n复制到当前激活的终端\n\n\nShift + PgUp / PgDown\n页面上下翻屏\n\n\nCtrl + Home / End\n滚动到页面头部或尾部\n\n\nVSCode 插件\nAuto Close Tag 自动闭合 HTML 标签\nAuto Import Typescript 自动 import 提示\nAuto Rename Tag 修改 HTML 标签时，自动修改匹配的标签\nBeautify css/sass/scss/less css/sass/less 格式化\nBetter Align 对齐赋值符号和注释\nBetter Comments 编写更加人性化的注释\nBookmarks 添加行书签\nBracket Pair Colorizer 用不同颜色高亮显示匹配的括号\nCSS Peek - 追踪至样式表中 CSS 类和 id 定义的地方\nCan I Use HTML5、CSS3、SVG 的浏览器兼容性检查\nCode Runner 运行选中代码段（支持大量语言，包括 Node）\nCode Spellchecker 单词拼写检查\nCodeBing 在 VSCode 中弹出浏览器并搜索，可编辑搜索引擎\nColor Highlight 颜色值在代码中高亮显示\nColor Info 小窗口显示颜色值，rgb,hsl,cmyk,hex 等等\nColor Picker 拾色器\nDash 集成 Dash\nDebugger for Chrome 调试 Chrome\nDocument This 注释文档生成\nESLint ESLint 插件，高亮提示\nEditorConfig for VS Code EditorConfig 插件\nEmoji 在代码中输入 emoji\nFile Peek 根据路径字符串，快速定位到文件\nfileheader 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间\nfilesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间\nftp-sync 同步文件到 ftp\nFont-awesome codes for html FontAwesome 提示代码段\nGit Blame 在状态栏显示当前行的 Git 信息\nGit History(git log) 查看 git log\nGitLens 显示文件最近的 commit 和作者，显示当前行 commit 信息\nGuides 高亮缩进基准线\nGulp Snippets Gulp 代码段\ngitignore .gitignore 文件语法\nHTML Snippets - html 代码片段以及提示\nHTML CSS Class Completion CSS class 提示\nHTML CSS Support css 提示（支持 vue）\nHTMLHint HTML 格式提示\nhtmltagwrap 包裹 HTML\nIcon Fonts 能够在项目中添加图标字体的插件。该插件支持超过 20 个热门的图标集，包括了 Font Awesome、Ionicons、Glyphicons 和 * Material Design Icons\nImage Preview 鼠标移到路径里显示图像预览\nImport Cost 行内显示导入（import/require）的包的大小\nIndenticator 缩进高亮\nIntelliSense for css class names css class 输入提示\nJavaScript (ES6) code snippets ES6 语法代码段\nJavaScript Standard Style Standard 风格\njQuery Code Snippets - jquery 提示\nJSON to TS JSON 结构转化为 typescript 的 interface\nJSON Tools 格式化和压缩 JSON\nLess IntelliSense less 变量与混合提示\nLodash Lodash 代码段\nLog Wrapper 生产打印选中变量的代码\nlanguage-stylus Stylus 语法高亮和提示\nMochaSnippets Mocha 代码段\nmarkdownlint Markdown 格式提示\nnpm Intellisense 导入模块时，提示已安装模块名称\nnpm 运行 npm 命令\nNode modules resolve 快速导航到 Node 模块\nCode Outline 展示代码结构树\nOutput Colorizer 彩色输出信息\nPartial Diff 对比两段代码或文件\nPath Autocomplete 路径完成提示\nPath Intellisense 另一个路径完成提示\nPostCss Sorting css 排序\nPrettify JSON 格式化 JSON\nProject Manager 快速切换项目\nQuokka.js 不需要手动运行，行内显示变量结果\nREST Client 发送 REST 风格的 HTTP 请求\nReact Native Storybooks storybook 预览插件，支持 react\nReact Playground 为编辑器提供一个 react 组件运行环境，方便调试\nReact Standard Style code snippets react standar 风格代码块\nSass sass 插件\nSettings Sync VSCode 设置同步到 Gist\nSort Typescript Imports typescript 的 import 排序\nSort lines 排序选中行\nString Manipulation 字符串转换处理（驼峰、大写开头、下划线等等）\nSVG Viewer SVG 查看器\nSyncing vscode 设置同步到 gist\nstylelint css/sass/less 代码风格\nTODO Parser Todo 管理\nTS/JS postfix completion ts/js 后缀提示\nTSLint TypeScript 语法检查\nTest Spec Generator 测试用例生成（支持 chai、should、jasmine）\nTypeScript Import TS 自动 import\nTypeSearch TS 声明文件搜索\nTypes auto installer 自动安装@types 声明依赖\nVSCode Great Icons 文件图标拓展\nVersion Lens package.json 文件显示模块当前版本和最新版本\nView Node Package 快速打开选中模块的主页和代码仓库\nVueHelper Vue2 代码段（包括 Vue2 api、vue-router2、vuex2）\nView In Browser - 可以使用快捷键 ctrl+F1 用浏览器打开文件\nvetur 目前比较好的 Vue 语法高亮\nvscode-database 操作数据库，支持 mysql 和 postgres\nvscode-icons 文件图标，方便定位文件\nvscode-random 随机字符串生成器\nvscode-spotify 集成 spotify，播放音乐\nvscode-styled-components styled-components 高亮支持\nvscode-styled-jsx styled-jsx 高亮支持\n\n","slug":"VSCode常用快捷键与插件","date":"2018-04-08T05:44:48.000Z","categories_index":"VSCode","tags_index":"VSCode","author_index":"Bobby's Blog"},{"id":"047e35790a0ea860fdedd509f300d020","title":"Sublime常用快捷键和插件","content":"Sublime Text 具有漂亮的用户界面和强大的功能，例如代码缩略图，Python 的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持 Windows、Linux、Mac OS X 等操作系统。官网下载地址： https://www.sublimetext.com/。\n\n\n快捷键参考选择类\nCtrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。\nAlt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。\nCtrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。\nCtrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。\nCtrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。\nCtrl+M 光标移动至括号内结束或开始的位置。\nCtrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。\nCtrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。\nCtrl+Shift+[ 选中代码，按下快捷键，折叠代码。\nCtrl+Shift+] 选中代码，按下快捷键，展开代码。\nCtrl+K+0 展开所有折叠代码。\nCtrl+← 向左单位性地移动光标，快速移动光标。\nCtrl+→ 向右单位性地移动光标，快速移动光标。\nshift+↑ 向上选中多行。\nshift+↓ 向下选中多行。\nShift+← 向左选中文本。\nShift+→ 向右选中文本。\nCtrl+Shift+← 向左单位性地选中文本。\nCtrl+Shift+→ 向右单位性地选中文本。\nCtrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。\nCtrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。\nCtrl+Alt+↑ 或 Ctrl+Alt+鼠标向上拖动 向上添加多行光标，可同时编辑多行。\nCtrl+Alt+↓ 或 Ctrl+Alt+鼠标向下拖动 向下添加多行光标，可同时编辑多行。\n\n多重选择（Multi-Selection）多重选择功能允许在页面中同时存在多个光标，让很多本来需要正则表达式、高级搜索和替换才能完成的任务也变得游刃有余了。激活多重选择的方法有两几种：\n\n按住 Ctrl 然后在页面中希望中现光标的位置点击。\n选择数行文本，然后按下 Shift + Ctrl + L。\n通过反复按下 Ctrl + D 即可将全文中与光标当前所在位置的词相同的词逐一加入选择，而直接按下 Alt+F3 即可一次性选择所有相同的词。\n按下鼠标中键来进行垂直方向的纵列选择，也可以进入多重编辑状态。\n\n编辑类\nCtrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的 CSS 属性合并为一行。\nCtrl+Shift+D 复制光标所在整行，插入到下一行。\nTab 向右缩进。只对光标后（或者选中的）的代码有效\nShift+Tab 向左缩进。\nCtrl+[ 向左缩进。对整行有效\nCtrl+] 向右缩进。对整行有效\nCtrl+K+K 从光标处开始删除代码至行尾。按住 Ctrl，按两次 K。\nCtrl+Shift+K 删除整行。\nCtrl+/ 注释单行。\nCtrl+Shift+/ 注释多行。\nCtrl+K+U 转换大写。\nCtrl+K+L 转换小写。\nCtrl+Z 撤销。\nCtrl+Y 恢复撤销。\nCtrl+U 软撤销，感觉和 Gtrl+Z 一样。\nCtrl+F2 设置书签，F2 切换书签\nCtrl+T 左右字母互换。\nF6 单词检测拼写\n\n搜索类\nCtrl+F 打开底部搜索框，查找关键字。\nCtrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是 sublime 允许添加多个文件夹进行查找，略高端，未研究。\nCtrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，* 跳转到文件中该行代码，4、输入#和关键字，查找变量名。\nCtrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。\nCtrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。\nCtrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。\nEsc 退出光标多行选择，退出搜索框，命令框等。\nCtrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用 sublime text 或插件的功能，例如使用 package 安装插件。\n\n显示类\nCtrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。\nCtrl+PageDown 向左切换当前窗口的标签页。\nCtrl+PageUp 向右切换当前窗口的标签页。\nAlt+Shift+1 窗口分屏，恢复默认 1 屏（非小键盘的数字）\nAlt+Shift+2 左右分屏-2 列\nAlt+Shift+3 左右分屏-3 列\nAlt+Shift+4 左右分屏-4 列\nAlt+Shift+5 等分 4 屏\nAlt+Shift+8 垂直分屏-2 屏\nAlt+Shift+9 垂直分屏-3 屏\nCtrl+K+B 开启/关闭侧边栏。\nF11 全屏模式\nShift+F11 免打扰模式\n\n跳转\nCtrl + P：列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后 Enter 跳转至该文件，输入@symbol 跳转到 symbol 符号所在的位置，输入#keyword 跳转到 keyword 所在的位置，输入:n 跳转到文件的第 n 行\nCtrl + R：列出当前文件中的符号（例如类名和函数名，但无法深入到变量名），输入符号名称 Enter 即可以跳转到该处。\n会列出 Markdown 文件的大纲\nF12： 快速跳转到当前光标所在符号的定义处（Jump to Definition）。比如当前光标所在为一个函数调用，F12 会跳转至该函数的定义处。\nCtrl + G： 输入行号以跳转到指定行\nCtrl+M：跳转到括号另一半。\n\n窗口和 Tab 页\nCtrl + N： 在当前窗口创建一个新标签\nCtrl + Shift + N： 创建一个新窗口（该快捷键 和搜狗输入法快捷键冲突）\nCtrl + W： 关闭标签页，如果没有标签页了，则关闭该窗口\nCtrl+Shift+W：关闭所有打开文件\nCtrl + Shift + T： 恢复刚刚关闭的标签。\nCtrl +Tag：移动标签。\n\n切换普通全屏\nShift + F11： 切换无干扰全屏\nAlt + Shift + 2： 进行左右分屏\nAlt + Shift + 8 进行上下分屏\nAlt + Shift + 5 进行上下左右分屏（即分为四屏）\nCtrl + 数字键： 跳转到指定屏\nCtrl + Shift + 数字键： 将当前屏移动到指定屏\n\n前端开发必备插件\nauto-save - 自动保存文件\nAllAutocomplete - 补全提示\nTag - HTML/XML 标签缩进、补全、排版和校验工具\nautoprefixer - 添加浏览器厂商前缀\nDocBlockr - 快速生成各种注释格式\nAutoFileName - 自动补全文件路径-非常方便\nTrailing spaces - 检测并一键去除代码中多余的空格\nSideBarEnhancement - SublimeText 的边栏菜单带来扩充的功能，包括：在当前工程文件夹中新建文件，移动文件或文件夹，产生文件或文件夹的副本，在新窗口或浏览器中打开，刷新等\nemmet - 一个可以极大提高 web 开发者 HTML 和 CSS 工作效率的工具箱组件\nHtml5 - html5 提示\nCSS3 - CSS3 语法高亮、CSS 语法提示，美中不足的是缺少游览器私有属性高亮。\nCSS Extended Completions - 关联 CSS 文件，智能提示 css 文件中的类名，非常好用\nJavaScript Completions - 支持 javascript 原生语法提示，妈妈再也不用担心我输入 document.getElementById(id)\njQuery - 为 jQuery 的大部分方法提供了示例代码段，让 jQuery 的 API 更加容易使用\nBracketHighlighter - 以让你选中的括号以及标签层级显示，不用担心选中的代码属于哪个代码块，对代码结构一目了然\nColorHighlighter - 它可以展示你所选择的颜色代码（像“#FFFFFF”, “rgb(255,255,255)”, “white”）的真正颜色。同时它还包含一个颜色选择器让你可以方便地更改颜色\nColorPicker - 经常要查看或设置颜色值，这个插件可以很方便地调用你本机的调色板应用\nBracketHighlighter - 括号以及标签层级显示，不用担心选中的代码属于哪个代码块，一目了然\nAlignTab – 代码对齐神器。使用简单的正则匹配要对齐的位置\nAlignment - 能对齐你的代码，包括 PHP、CSS 和 Javascript。代码看起来更简洁和可读，便于编辑, 默认的快捷键是 Ctrl+Alt+A\nGit - 可以在 SublimeText 中运行 Git 命令，包括添加，提交文件，查看日志，文件注解以及其它 Git 功能\nConvertToUTF8 – gbk 转 utf8\nGBK Encoding Support - 识别 GBK 和 ANS\nCanIUse - 检查浏览器是否支持你包括在你的代码中的 CSS 和 HTML 元素\nCSSComb - CSS 属性进行排序\nStylefmt – css 代码规范修正，使用 stylelint 规则\ncssrem – px 转 rem (https://github.com/flashlizi/cssrem)\nHTML-CSS-JS Prettify – THML、CSS、JS 代码格式化，压缩过后的代码可以通过该工具复原, 快捷键是 ctrl+shift+h\nJsFormat - javascript 格式化工具\nJsMinifier - 自动压缩 js 文件\nsublimeCodeIntel - 代码自动补全，支持多种语言的自动补全\nSublimeLinter – 代码检查工具\nSublimeLinter-contrib-eslint – JavaScript 代码规范校验\nSublimeLinter-contrib-stylelint – css 代码规范校验\nMarkdownEditing – markdown 编辑助手\nMarkdownPreview – 将 markdown 转换为 html 预览。支持 github 的 API 调用生成。我是经常用\nTerminal – 在当前文件路径下打开 shell\nLESS – less 语法支持\nSASS – SASS 语法支持\njavascript next - javascript ES6 语法高亮的支持\nAngularJS - angularJS 代码提示\nTypeScript – TypeScript 代码语法支持\nVue syntax Highlight – vue.js 语法支持\nPretty JSON：格式化出漂亮的 json\nNodejs - node 代码提示\nSublimeServer - 静态 WEB 服务器\nLiveReload - 网页浏览器页面重新加载插件\nview in browser - 通过默认浏览器打开文件\n\n","slug":"Sublime常用快捷键和插件","date":"2018-03-28T11:05:56.000Z","categories_index":"Sublime","tags_index":"Sublime","author_index":"Bobby's Blog"},{"id":"6e82e2667bdd280551a9f400dacb0b9c","title":"JavaScript基本构造图","content":"1)、数据类型 2)、变量 3)、运算符 4)、流程语句 5)、数组 6)、函数基础 7)、字符串函数 8)、BOM 9)、DOM 10)、正则表达式\n\n\n数据类型\n\n变量\n### 运算符\n\n### 流程语句\n\n### 数组\n\n### 函数基础\n\n### 字符串函数\n\n### BOM\n\n### DOM\n\n### 正则表达式\n\n","slug":"JavaScript基本构造图","date":"2018-03-20T15:24:37.000Z","categories_index":"JS","tags_index":"JS","author_index":"Bobby's Blog"},{"id":"5e2fd42de480c36198e0d3e8d7681a42","title":"前端知识学习汇总","content":"核心 CoreHTML5W3C http://www.w3school.com.cn/html5/W3C https://www.w3.org/html/ig/zh/wiki/HTML5菜鸟教程 http://www.runoob.com/html/html5-intro.htmlHTML5 中文门户 http://www.html5cn.org/\nCSS3W3C CSS 教程 http://www.w3school.com.cn/css/index.aspW3C CSS3 教程 http://www.w3school.com.cn/css3/index.asp菜鸟教程 CSS 教程 http://www.runoob.com/css/css-tutorial.html菜鸟教程 CSS3 教程 http://www.runoob.com/css3/css3-tutorial.htmlCSS 参考手册 http://css.doyoe.com/\nJSW3C http://www.w3school.com.cn/js/菜鸟教程 http://www.runoob.com/js/js-tutorial.html廖雪峰 js 教程 http://www.liaoxuefeng.comjs 标准参考教程-阮一峰http://javascript.ruanyifeng.com/\njQueryW3C http://www.w3school.com.cn/jquery/菜鸟教程 http://www.runoob.com/jquery/jquery-tutorial.html极客学院 http://wiki.jikexueyuan.com/project/jquery-tutorial/廖雪峰 http://www.liaoxuefeng.com/wiki/参考手册 http://www.css88.com/jqapi-1.9/参考手册 http://www.runoob.com/manual/jquery/\nES6阮一峰 ES6 http://es6.ruanyifeng.com/极客学院 http://wiki.jikexueyuan.com/project/es6/JavaScript 标准参考　阮一峰http://javascript.ruanyifeng.com/advanced/ecmascript6.html\n\n\n插件parallel.js: 前后端通用的一个并行库zepto: 用于现代浏览器的兼容 jQuery 的库totoro: 稳定的跨浏览器测试工具TheaterJS: 一个用于模拟人输入状态的 JS 库stellar.js: 前端用于实现异步滚动效果的库，现已不再维护skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前端效果，看真相Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序regulex: 用于生成 正则表达式 的可视化流程图markdown-it: 新型 Markdown 解析器，快速，支持插件multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Docscreenfull.js: 全屏插件，支持各大浏览器lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用jquery.hotkeys: jQuery 插件，用于绑定热键breach_core: Javascript 编写的 Browser (浏览器)octocard: 用于生成 Github 信息卡片的库github-cards: 用于生成 Github 信息卡片的库money.js: 轻量级货币转换库，web 和 node 皆可用accounting.js: 轻量级的数字、货币转换库javascript-algorithms: Javascript 实现的各种算法集合lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升seajs: 前端模块加载器，解决模块化、依赖等问题jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库js.js: Javascript 实现的 javascript JITjquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大todomvc: 分别基于 AngularJS/EmberJS/Backbone 等实现的 TODO List, 帮助开发者选择前端 MVC 库localForage: Mozilla 出品，用于离线存储，基于 IndexedDB, WebSQL 或者 localStorage, 提供一致的接口EventEmitter: 浏览器版的 EventEmitterjquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据knockout: 前端 MVVM 框架，用于开发富前端应用mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品zoomooz: jQuery 插件，用来处理浏览器缩放fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 Reactbackbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果jquery-validation: jQuery 的一个插件，用于校验 Form 表单BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度qrcode-generator: 各种语言的二维码生成工具device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 Javascript 和 CSSjquery-qrcode: jQuery 插件，用来生成二维码Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demolazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片progressbar.js: 简洁美观的进度条，扁平化pigshell: 一个由 Javascript 实现的 Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务spectrum: Js 实现的颜色选择器 (Colorpicker)jQuery.countdown: jQuery 倒计时插件summernote: WYSIWYG 富文本编辑器awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器trix: Basecamp 公司出品的富文本编辑器，简洁小巧sensor.js: 在智能移动设备浏览器上，通过 HTML5 的 api 使用移动设备的功能。定位、运动、倾斜等hyhyhy: 用于创建 基于 HTML5 的 演示文稿swipebox: jQuery 插件，用于处理移动端的触摸事件FileAPI: 前端用户处理文件（拖放、多文件上传等）Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuerySwiper: 用于实现浏览器上的滑动切换效果，支持硬件加速matter-js: 2D 物理效果引擎，碰撞、弹跳等jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库c3: 基于 D3 的图表库echarts: 企业级图表库，百度开发parallax.js: 一个用于响应智能手机 orientation 的库jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器wysihtml: 富文本编辑器，适用于现代浏览器slip: 一个通过滑动或者拖拽来操控列表的库evil-icons: 一个矢量图库，提供 Ruby/Node 等支持PhotoSwipe: JS 的一个图片展示库focusable: 是页面上一个元素高亮的库，有图有真相firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefoxjquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5mobile-angular-ui: 基于 angularjs 和 bootstarp 的 web app 开发框架interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库rebound-js: 实现部分物理效果，Facebook 出品basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品accessible-html5-video-player: Paypal 出品的 Video 播放器loading: 几种 Loading 效果，基于 SVGflippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的move.js: 基于 CSS3 的前端动画框架scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 DemoModernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库foundation: 另一款前端模版框架，类似于 BootstrapFlat-UI: Bootstrap 的一款主题，简洁美观iCheck: 一款漂亮的 Checkbox 插件Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kbslick: 功能异常强大的一个图片滑动切换效果库SocialButtons: 漂亮的社交按钮sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库web-animations-js: Javascript 实现的 Web Animation APIvivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画plyr: 轻量, 小巧, 美观的 HTML5 视频播放器timesheet.js: 基于 HTML5 &amp; CSS3 时间表slideout: 一个非常美观的侧滑菜单\n包管理工具 Package ManagersNPM菜鸟教程 NPM 使用介绍 http://www.runoob.com/nodejs/nodejs-npm.html淘宝 NPM 镜像 https://npm.taobao.org/npm 模块安装机制简介 http://www.ruanyifeng.com/blog/2016/01/npm-install.htmlnpm 包搜索地址 https://www.npmjs.com/\nBowerBower 中文网 http://www.bowercn.com/Bower：客户端库管理工具-阮一峰 http://javascript.ruanyifeng.com/tool/bower.html\nYarnyarn 中文网 https://yarnpkg.com/zh-Hans/快速、可靠、安全的依赖管理YARN 简介 https://www.ibm.com/developerworks/cn/data/library/bd-yarn-intro/\n前端性能 Front-End PerformanceWebPagetestPerfBudgetCriticalCSSPicturefill\n编辑器 Text EditorsSublimeText官网下载 https://www.sublimetext.com/前端网破解版插件版下载 http://www.qdfuns.com/toolsSublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言Emmet：一个用于提高开发效率的编辑器插件，前身是 Zen codingSublimeLinter: 一个提供代码质量检测的插件SublimeTmpl：快速新建指定的模版文件Syntax-highlighting-for-Sass：sass 代码高亮插件MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等ApplySyntax: 辅助检测语法插件CTags: Sublime Text Ctags 支持插件, 需要安装 ctagssublime-react: React 代码高亮\nAtom官网下载 https://atom.io/\nWebStorm官网下载 http://www.jetbrains.com/webstorm/download前端网破解版下载 http://www.qdfuns.com/tools\nVScode官网下载 https://code.visualstudio.com/vscode 插件精选 - 献给所有前端工程师https://segmentfault.com/a/1190000006697219\nHBuilder官网下载 http://www.dcloud.io/\nJS 框架 JS FrameworksVuevue 官方http://cn.vuejs.org/vuex 官方http://vuex.vuejs.org/zh-cn/vue-router 官方https://router.vuejs.org/zh-cn/\nReact英文官方文档https://facebook.github.io/react/docs/hello-world.html中文官方文档http://reactjs.cn/react/docs/getting-started-zh-CN.htmlgitbooks 手册https://hulufei.gitbooks.io/react-tutorial/content/introduction.html阮一峰 react 入门http://www.ruanyifeng.com/blog/2015/03/react.html阮一峰 React Router 入门http://www.ruanyifeng.com/blog/2016/05/react_router.htmlReact Router 中文文档https://react-guide.github.io/react-router-cn/react-redux 中文文档http://cn.redux.js.org/docs/react-redux/index.html阮一峰 Redux 入门教程http://www.ruanyifeng.com/blogreact: React 框架源代码react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架react-hot-loader: 实时调整 React 组件效果grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JStouchstonejs: 基于 React 的手机应用前端框架essential-react: 基于 React, ES6, React-Router 的一个应用脚手架react-router: React 路由解决方案\nAngularJs中文官方文档https://angular.cn/angularjs 中文网http://www.apjs.net/angularjs 教程http://www.angularjs.net.cn/Angular 基础入门http://www.cnblogs.com/micua/p/angular-essential.htmlangular-masonry: Masonry 的 AngularJS 插件，用于瀑布流angular-schema-form: 根据 JSON 生成响应的 Form 表单restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resourceng-cordova: Cordova 常用组件的 Angular 版本angular-translate: Angular 的国际化 (I18n)ng-inspector: Chrome 插件，用于调试 Angularangularjs-style-guide: AngularJS 代码风格ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Componentsmaterial: Google Material Design 效果的 Angular 实现angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级angular-filter: 一组有用的 Angular Filtersbindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能\nBackboneBackbone.js API 中文文档http://www.css88.com/doc/backbone/\nUI 框架 UI FrameworksBootstrap最受欢迎的 HTML、CSS 和 JS 框架 http://v3.bootcss.com/\nIonic一款接近原生的 Html5 移动 App 开发框架　会 html css js 就可以开发 apphttp://www.ionic.wang/\nFoundationFoundation 中文网 迄今为止最好的响应式前端框架http://www.foundcss.com\nFrozenUI移动端服务的前端框架http://frozenui.github.io/\nmui最接近原生 APP 体验的高性能前端框架http://dev.dcloud.net.cn/mui/\nAntDesign和 react 配合的 UI 框架https://ant.design\neleme和 vue 配合的 UI 框架http://element.eleme.io/\nJS 预处理 JS PreprocessorsTypeScriptTypeScript 入门教程 菜鸟教程http://www.runoob.com/TypeScript 中文网https://www.tslang.cn/TypeScript 教程 gitbookhttps://www.gitbook.com/\nCoffeeScriptCoffeeScript 中文http://coffee-script.org/CoffeeScript 实用手册 极客学院http://wiki.jikexueyuan.com/project/coffeescript/\n响应式网页 Responsible WEB Design渐进增强、可访问性\n过程自动化 Process AutomationGruntGrunt 中文网http://www.gruntjs.net/\nGulpgulp.js 中文网http://www.gulpjs.com.cn/gulp 详细入门教程http://www.ydcss.com/前端构建工具 gulpjs 的使用介绍及技巧http://www.cnblogs.com/2050/p/4198792.htmlGulp 开发教程https://www.w3ctech.com/topic/134\n模板引擎 TemplatingHandlebarshandlebarsjs 官网http://handlebarsjs.com/Handlebars 中文文档http://www.360doc.com/content/Handlebars.js 中文文档http://keenwon.com/992.htmlHandlebars 的使用方法文档整理http://www.tuicool.com/articles/fqQFN3\nHamlhaml 官方文档https://github.com/haml/hamlhaml 入门http://blog.csdn.net/napoay/article/details/50491363\nJadeJade 官方的英文文档http://www.w3cplus.com/html/how-to-use-jade.htmlJade 的使用http://www.w3cplus.com/html/how-to-use-jade.html带你学习 Jade 模板引擎视频http://www.imooc.com/learn/259\n代码质量 Code QualityJSCSESLint\n浏览器刷新 Browser RefreshingLiveReloadGuard\n构建工具 Build ToolsRequireJSRequireJS 英文网http://requirejs.org/RequireJS 中文网http://requirejs.cn/require.js 的用法-阮一峰http://www.ruanyifeng.com/blog\nseajsseajs 文档http://seajs.org/docs/SeaJS 从入门到原理http://www.tuicool.com/articles/FfEJv2u\nBrowserify官网http://browserify.org/githubhttps://github.com/substack/node-browserify/\nWebpackWebpack 中文指南http://webpackdoc.com/webpack 的实例http://www.vichily.comwebpack 的入门http://www.vichily.com一小时包教会 —— webpack 入门指南http://www.w2bc.com/Article/50764\nCSS 预处理器 CSS PreprocessorsSasssass 入门http://www.w3cplus.com/sassguide/sass 参考手册http://sass.bootcss.com/docs/sass-reference/SASS 用法指南-阮一峰http://www.ruanyifeng.com/blog/\nLessless 中文网http://lesscss.cn/less 快速入门http://less.bootcss.com/\nstylusstylus 中文文档-张鑫旭http://www.zhangxinxu.com/jq/stylus/\n后端 Back-EndnodeJSPHP\n版本控制 Version ControlGitGit 教程-廖雪峰http://www.liaoxuefeng.com/wiki/\nSvn史上最简单的 SVN 使用教程和注意事项http://blog.csdn.net/fwzkj/article/details/47988885SVN 教程 极客学院http://wiki.jikexueyuan.com/project/svn/SVN 教程 菜鸟教程http://www.runoob.com/svn/svn-tutorial.html\n","slug":"前端知识学习汇总","date":"2018-03-14T10:55:12.000Z","categories_index":"前端","tags_index":"前端","author_index":"Bobby's Blog"},{"id":"c3209194ebb7370e558fc3ba6b6ebd98","title":"后端学习","content":"PHPPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\n\n\n变量类型整型 Integer浮点型 Float字符串 String字符串函数\nimplode() — 将一个一维数组的值转化为字符串(数组转成字符串)\nexplode — 使用一个字符串分割另一个字符串(拆分成数组)\nstr_pad() — 使用另一个字符串填充字符串为指定长度\nstr_repeat() — 重复一个字符串\nstr_replace() — 子字符串替换\nstr_split() — 将字符串转换为数组\nstrpos() — 查找字符串首次出现的位置\nstrlen() — 获取字符串长度\nstrstr() — 查找字符串的首次出现,返回字符串从第一次出现的位置开始到结尾的字符串\nstrtolower() — 将字符串转化为小写\nstrtoupper() — 将字符串转化为大写\nsubstr_count() — 计算字串出现的次数\nsubstr_replace() — 替换字符串的子串\nsubstr() — 返回字符串的子串(截取)\ntrim() — 去除字符串首尾处的空白字符（或者其他字符）\n\n布尔型 Boolean数组 Array数组函数\ncount() — 计算数组中的单元数目，或对象中的属性个数\nin_array() — 检查数组中是否存在某个值\narray_keys() — 返回数组中部分的或所有的键名\narray_values() — 返回数组中所有的值\narray_pop() — 弹出数组最后一个单元（出栈）\narray_push() — 将一个或多个单元压入数组的末尾（入栈）\narray_shift()— 将数组开头的单元移出数组\narray_unshift() — 在数组开头插入一个或多个单元\narray_combine() — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值\narray_sum() — 对数组中所有值求和\narray_filter() — 用回调函数过滤数组中的单元\narray_flip() — 交换数组中的键和值\narray_map() — 为数组的每个元素应用回调函数\narray_merge() — 合并一个或多个数组\n()\n\n对象 Object空值 NULLNULL 值表示变量没有值,NULL 类型唯一可能的值就是 NULL。\n资源 Resource变量\nisset() — 检测变量是否已设置并且非 NULL\nunset() — 销毁指定的变量\ngettype() — 获取变量的类型\nget_resource_type() — 返回资源（resource）类型\n\n变量检测\nempty() — 检查一个变量是否为空\nis_int() — 检测变量是否是整数\nis_numeric — 检测变量是否为数字或数字字符串\nis_scalar — 检测变量是否是一个标量\nis_float() — 检测变量是否是浮点型\nis_string() — 检测变量是否是字符串\nis_bool() — 检测变量是否是布尔型\nis_array() — 检测变量是否是数组\nis_object() — 检测变量是否是一个对象\nis_null() — 检测变量是否为 NULL\nis_resource() — 检测变量是否为资源类型\n\n流程控制MYSQL（关系型数据库）\ncmd: mysql -uroot -p\ngit bush: winpty mysql -uroot -p\nhelp\nstatus\nshow processlist;\nshow global variables like ‘socket’;\nshow variables like ‘%char%’; 查看编码\nset names gbk;\nflush privileges; 刷新权限\nshow databases; 查看数据库\ncreate database 数据库名; 创建数据库\ndrop database 数据库名; 删除数据库\nuse test; 进入 test 数据库(切换数据库)\ncreate table 表名(\nid int unsigned(无符号) not null(不为空) auto_increment(自增) comment ‘用户 id’,\nuser_name varchar(20) not null comment ‘用户名’,\nemail varchar(50) not null comment ‘邮箱’,\nage tinyint unsigned not null comment ‘年龄’,\ncreated_at timestamp not null comment ‘注册时间’,\nprimary key(id)\n);\nshow tables; 查看当前数据库的表\ndesc 表名; 查看表字段\nshow create table 表名; 查看创建表的 sql 语句\ndrop table 表名; 删除表\nalter table 表名 modify user_name varchar(50) not null; 修改表字段\nalter table 表名 change email user_email varchar(50) not null; 修改\nalter table 表名 add password char(32) not null comment ‘密码’ after user_name; 添加\nalter table 表名 drop password; 删除\nalter table 表名 rename (to) 新表名; 重命名\nselect * from 表名; 查询表数据\ninsert into 表名 (列 1,列 2, ….) values (列值 1,列值 2,…); 插入数据\nupdate 表名 set 字段名=值 where id=1; 更新\ndelete from 表名 where id=1; 删除\ntruncate 表名; 整个删除，插入数据重排\n\n\n修改密码：\n1).\nuse mysql;\nselect user,host,password from user;\nupdate user from password=PASSWORD(‘admin’) where user=’root’;\nflush privileges;\ncreate user ‘test’@’192.168.1.8’ indentified by ‘123456’; 创建用户,要刷新权限\nmysql -utest -h192.168.1.8 -p123456\ngrant update,insert,delate on 数据库名.* to ‘test’@’192.168.1.8’; 用户授权\nrevoke update,insert,delate on 数据库名.* from ‘test’@’192.168.1.8’; 撤销授权\ndrop user ‘test’@’192.168.1.8’ 删除\n\n2).\nmysqladmin -uroot -padmin password root\n\n3).\nmysqld –skip-grant-tables; 跳过权限表，再开一个进程\n\nGIT\nmkdir 创建目录\ntouch 创建文件\n.gitignore 版本忽略文件配置\nrm -rf 刪除\ngit config –global user.email ‘user@gmail.com’\ngit config –global user.name ‘user’\ngit config –global alias.a add git add . 命令改成简写 git a .\ngit init 初始化本地 git 仓库（创建新仓库）\ngit status 查看当前版本状态（是否修改）\ngit add . /git add -A\ngit commit -m ‘’\ngit commit –amend -m ‘’ 合并上一次提交（用于反复修改）\ngit commit -am ‘’ 将 add 和 commit 合为一步\ngit log 显示提交日志\ngit log -p git log -p 1\ngit log –oneline git log –oneline -p\ngit log –name-only git log –name-status\ngit rm 删除文件(版本库与本地都删)\ngit rm –cached 只删除版本库文件\ngit clone 克隆\ngit mv README README2 重命名文件 README 为 README2\ngit branch 查看分支\ngit branch -a 显示所有分支(远程分支)\ngit branch xx 创建 xx 分支\ngit checkout xx 切换到 xx 分支\ngit checkout -b xx 创建 xx 分支并切换到 xx 分支\ngit merge xx 合并分支\ngit branch -d xx 删除分支\ngit branch –merged 显示所有已合并到当前分支的分支\ngit branch –no-merged 显示所有未合并到当前分支的分支\ngit stash 暂存当前修改，将所有至为 HEAD 状态\ngit stash list 查看所有暂存\ngit stash apply 恢复暂存区\ngit stash drop stash@{0} 删除某个暂存区\ngit stash pop 删除暂存区\ngit tag 显示已存在的 tag\ngit tag v0.01 打 tag\ngit archive master –prefix=‘hdcms/’ –forma=zip &gt; hdcms.zip 打包成 zip 文件\ngit rebase master 把子分支基础点移动到 master 最新 commit 点，在切换到 master 进行 merge 合并\ngit remote add origin git@github:xxx 与远程仓库关联\ngit push origin master 推送到远程仓库\ngit remote -v 查看远程仓库\ngit pull origin xxx:xxx 把远程仓库子分支检出到本地\ngit push origin –delete xx 把远程子分支删除\n\n","slug":"后端学习","date":"2018-03-12T16:00:00.000Z","categories_index":"PHP","tags_index":"PHP","author_index":"Bobby's Blog"},{"id":"862ecabae65544f00e4a4f42f663a791","title":"Hexo","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\nHexoGitHub\nQuick Startnpm install -g hexo-cli\n\n安装以后，可以使用以下两种方式执行 Hexo：\n1. npx hexo &lt;command&gt;\n2. 将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo &lt;command&gt;：\necho &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile\n\nCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nclean$ hexo clean\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)\n","slug":"Hexo搭建","date":"2017-08-15T10:49:36.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"Bobby's Blog"}]