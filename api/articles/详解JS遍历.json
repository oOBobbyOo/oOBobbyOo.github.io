{"title":"详解JS遍历","uid":"9f17109abe732a77d87a2b0d4189145c","slug":"详解JS遍历","date":"2019-07-20T14:19:44.000Z","updated":"2021-05-14T10:40:31.703Z","comments":true,"path":"api/articles/详解JS遍历.json","keywords":null,"cover":"/assets/js.jpg","content":"<p>遍历数组或对象是一名程序员的基本素养之一，然而遍历却不是一件简单的事，优秀的程序员知道怎么去选择合适的遍历方法，优化遍历效率。本篇将带你走进 JavaScript 遍历的世界，享受分析 JS 循环的快感。本篇所有代码都可以直接运行，希望您通读本篇后，不止是浏览， 最好是亲手去实践下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"js-有如下两种数据需要经常遍历\"><a href=\"#js-有如下两种数据需要经常遍历\" class=\"headerlink\" title=\"js 有如下两种数据需要经常遍历\"></a>js 有如下两种数据需要经常遍历</h2><ul>\n<li>数组(Array)</li>\n<li>对象(Object)</li>\n</ul>\n<p>同时又提供了如下 8 种方法方便我们遍历数据</p>\n<ul>\n<li>for</li>\n<li>while(或 do~while)</li>\n<li>forEach</li>\n<li>for in</li>\n<li>$.each</li>\n<li>$(selecter).each</li>\n<li>map</li>\n<li>every</li>\n</ul>\n<p>通常我们需要根据数据选择合适的遍历方法，优化遍历效率，提高开发效率<br>接下来针对如下两种数据进行详细的分析和举栗:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var array &#x3D; [&#39;vue&#39;, &#39;react&#39;, &#39;angular&#39;]\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 3 &#125;</code></pre>\n\n<h3 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h3><p>语法: for(初始化; 循环执行条件; 每遍历一个元素后做的事情;){}</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">;(function () &#123;\n  &#x2F;&#x2F;循环置于闭包之内\n  for (var i &#x3D; 0, length &#x3D; array.length; i &lt; length; i++) &#123;\n    &#x2F;&#x2F;缓存数组长度\n    console.log(array[i]) &#x2F;&#x2F;vue react angular\n  &#125;\n&#125;)()</code></pre>\n\n<p>for 循环只能遍历数组, 不能遍历对象. 写 for 循环时有两点需要注意：</p>\n<ul>\n<li>其一,为了避免遍历时执行多遍计算数组长度的操作,影响效率,建议在循环开始以变量的形式缓存下数组长度, 若在循环内部有可能改变数组长度, 请务必慎重处理, 避免数组越界.</li>\n<li>JavaScript 中并没有类似 java 的块级作用域, for 循环内部定义的变量会直接暴露在外(如 i,循环退出后,i 变量将等于数组长度, 后续代码将能访问到 i 变量的值), 因此建议将 for 循环置于闭包内. 特别要注意的是: 如果在循环内部, 前一个元素的遍历有可能影响到后一个元素的遍历, 那么 for 循环内部方法也需要置于闭包之内.</li>\n</ul>\n<h3 id=\"do-while\"><a href=\"#do-while\" class=\"headerlink\" title=\"do/while\"></a>do/while</h3><p>语法: do{…}while(true);</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">;(function () &#123;\n  var i &#x3D; 0,\n    len &#x3D; array.length\n  do &#123;\n    if (i &#x3D;&#x3D; 2) &#123;\n      break &#x2F;&#x2F; 循环被终止, 此处如果是continue就会造成循环无法退出\n    &#125;\n    console.log(&#39;array[&#39; + i + &#39;]:&#39; + array[i])\n    i++ &#x2F;&#x2F;此句建议放置循环while头部\n  &#125; while (i &lt; len)\n&#125;)()</code></pre>\n\n<p>do/while 的语法简化了循环的实现, 只保留对循环条件的判断, 所以我们要在循环内部构造出循环退出的条件, 否则有可能造成死循环. 特别要注意的是: <strong>使用 continue 跳出本次遍历时, 要保证循环能够自动进入到下一次遍历, 因此保证循环走到下一次遍历的语句需要放到 continue 前面执行, 建议置于循环头部.</strong>(如上, i++ 语句最好放置循环头部)</p>\n<p>do/while 循环与 for 循环大体差不多,只支持数组遍历, 多用于对循环退出条件不是很明确的场景. 一般来说不建议使用这种方式遍历数组.</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>语法: array.forEach(function(item){}), 参数 item 表示数组每一项的元素</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">array.forEach(function (item) &#123;\n  if (item &#x3D;&#x3D; &#39;react&#39;) return &#x2F;&#x2F;这里只能使用return跳过当前元素处理\n  console.log(item) &#x2F;&#x2F;vue angular\n&#125;)</code></pre>\n\n<p>forEach 回调 function 默认有三个参数: item, index, array.<br>使用 forEach 循环有几点需要特别注意:</p>\n<ul>\n<li>forEach 无法遍历对象</li>\n<li>forEach 无法在 IE 中使用，只是在 firefox 和 chrome 中实现了该方法</li>\n<li>forEach 无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致</li>\n</ul>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h3><p>语法: for(var item in array){}</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">for (var item in array) &#123;\n  console.log(item) &#x2F;&#x2F;0 1 2\n&#125;\nfor (var item in obj) &#123;\n  console.log(item) &#x2F;&#x2F;0 1 2 length\n&#125;</code></pre>\n\n<p>for in 可用于遍历数组和对象, 但它输出的只是数组的索引和对象的 key, 我们可以通过索引和 key 取到对应的值. 如下:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">for (var item in array) &#123;\n  console.log(array[item]) &#x2F;&#x2F;vue react angular\n&#125;\nfor (var item in obj) &#123;\n  console.log(obj[item]) &#x2F;&#x2F;vue react angular 3\n&#125;</code></pre>\n\n<h3 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"$.each\"></a>$.each</h3><p>语法: $.each(array|obj, function(i, ele){}) 支持数组和对象</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$.each(array, function (i, ele) &#123;\n  console.log(i, ele, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot; true\n&#x2F;&#x2F;1 &quot;react&quot; true\n&#x2F;&#x2F;2 &quot;angular&quot; true\n\n$.each(obj, function (i, ele) &#123;\n  console.log(i, ele, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot; true\n&#x2F;&#x2F;1 &quot;react&quot; true\n&#x2F;&#x2F;2 &quot;angular&quot; true</code></pre>\n\n<p>这里我们注意到 this 对象 指向当前属性的值,这是因为:<br>参考 jQuery api:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$.each()方法会迭代 jQuery 对象中的每一个 DOM 元素。每次回调函数执行时，会传递当前循环次数作为参数(从 0 开始计数)。更重要的是，回调函数是在当前 DOM 元素为上下文的语境中触发的。因此关键字 this 总是指向这个元素。</p></blockquote>\n<p>同时,上述遍历时, obj 对象的属性中有一个 length 属性并没有被输出. 这是为什么呢? 请耐心往下看.<br>首先, 我们来看看遍历对象 obj 时, 当前的 this 对象到底是什么?</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$.each(obj, function (i, ele) &#123;\n  if (this &#x3D;&#x3D; &#39;linda&#39;) &#123;\n    &#x2F;&#x2F;我们随机选取第一个属性\n    console.log(this, this &#x3D;&#x3D; ele)\n    $.each(this, function (e, ele2) &#123;\n      console.log(e, ele2)\n    &#125;)\n  &#125;\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; true\n&#x2F;&#x2F;&quot;v&quot;\n&#x2F;&#x2F;&quot;u&quot;\n&#x2F;&#x2F;&quot;e&quot;</code></pre>\n\n<p>我们发现, this 对象等于回调函数的第二个形参. 且它的 length 属性和 [[PrimitiveValue]] 属性并没有被打印出来, 为此我们来查看下 length 的内部属性.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$.each(obj, function (i, ele) &#123;\n  if (this &#x3D;&#x3D; &#39;vue&#39;)\n    &#x2F;&#x2F;我们还是随机选取第一个属性(这还是随机吗?)\n    console.log(Object.getOwnPropertyDescriptor(this, &#39;length&#39;))\n&#125;)\n&#x2F;&#x2F;Object &#123;value: 3, writable: false, enumerable: false, configurable: false&#125;</code></pre>\n\n<p>可见, this 对象的 length 属性的 enumerable 属性被设置成了 false, 这表示该对象不能被列举或遍历, 同时还不能被配置(configurable: false), 也不能被赋值(writable: false).</p>\n<p>此时, 前面遍历 obj 对象时,它的 length 属性没有被打印出来的疑问似乎有解了. 让我们来看看 obj.length 的内部属性吧.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log(Object.getOwnPropertyDescriptor(obj, &#39;length&#39;))\n&#x2F;&#x2F;Object &#123;value: 3, writable: true, enumerable: true, configurable: true&#125;</code></pre>\n\n<p>obj.length 值为 3, 可赋值, 可列举, 可配置. 这可不对, 刚刚不是说 enumerable 属性被设置成了 false 才不会被遍历吗. 现在该值为 true, 并且还不可遍历. 这不合常理, 自然该有别的原因. 我们接着往下看.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 1 &#125; &#x2F;&#x2F; 试着改变length的值\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F;0 &quot;vue&quot;\n\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39;, length: 5 &#125; &#x2F;&#x2F; 坚持改变length的值\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F; 0 vue\n&#x2F;&#x2F; 1 react\n&#x2F;&#x2F; 2 angular\n&#x2F;&#x2F; length 5\n\nvar obj &#x3D; &#123; 0: &#39;vue&#39;, 1: &#39;react&#39;, 2: &#39;angular&#39; &#125; &#x2F;&#x2F; 试试去掉length属性\n$.each(obj, function (i, ele) &#123;\n  &#x2F;&#x2F;再遍历一次\n  console.log(i, ele)\n&#125;)\n&#x2F;&#x2F; 0 vue\n&#x2F;&#x2F; 1 react\n&#x2F;&#x2F; 2 angular</code></pre>\n\n<p>现象明了, 结合 jquery 源码, 当对象中存在 length 属性时, $.each 内部使用for循环去遍历对象, 否则它将使用for in循环去遍历, 因此$.each 遍历对象遵循如下规律:</p>\n<ul>\n<li>如果对象中存在 length 属性, 遍历深度以 length 属性为准, 即 length 多大, 遍历多少个元素.</li>\n<li>如果对象中不存在 length 属性, 遍历深度以实际内部属性个数为准.</li>\n</ul>\n<p>不仅如此, $.each 的具体使用过程中还有以下几点需要注意:</p>\n<ul>\n<li>使用 return 或者 return true 为跳过一个元素，继续执行后面的循环;</li>\n<li>使用 return false 为终止循环的执行, 这是因为在 jquery.each 中,若返回值指定为 false,才跳出循环, 如果感兴趣请翻看 jquery.each 源码;</li>\n<li>无法使用 break 与 continue 来跳过循环.</li>\n</ul>\n<h3 id=\"selecter-each\"><a href=\"#selecter-each\" class=\"headerlink\" title=\"$(selecter).each\"></a>$(selecter).each</h3><p>语法: $(selecter|array|o).each(function(i, ele){}) 支持数组和对象,该方法基本上与$.each 方法相同.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">$(&#39;div&#39;).each(function (i, ele) &#123;\n  console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;dom... 0 true\n\n$(array).each(function (i, ele) &#123;\n  &#x2F;&#x2F;处理数组\n  if (this &#x3D;&#x3D; &#39;vue&#39;) console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; 0 true\n\n$(obj).each(function (i, ele) &#123;\n  &#x2F;&#x2F;处理对象\n  if (this &#x3D;&#x3D; &#39;vue&#39;) console.log(this, i, this &#x3D;&#x3D; ele)\n&#125;)\n&#x2F;&#x2F;String &#123;0: &quot;v&quot;, 1: &quot;u&quot;, 2: &quot;e&quot;, length: 3, [[PrimitiveValue]]: &quot;vue&quot;&#125; 0 true</code></pre>\n\n<p>dom 表示 div 元素, 由于 this 恒等 ele, 说明 this 也表示 div 元素, 所以 this 并不是 jquery 对象, 而是普通的 DOM 对象(可以在 this 上随意使用 DOM 方法).使用$(selecter).each 方法,请注意以下几点:</p>\n<ul>\n<li>i: 即序列值 ele: 表示当前被遍历的 DOM 元素</li>\n<li>this 表示当前被遍历的 DOM 元素，不能调用 jQuery 方法, 如需调用 jquery 方法需要用$符号包裹.如, $(this)</li>\n</ul>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>即 Array.prototype.map,该方法只支持数组<br>语法: array.map(callback[,thisArg]) map 方法使用其提供函数的每次返回结果生成一个新的数组.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var array &#x3D; [1, 4, 9]\nvar roots &#x3D; array.map(Math.sqrt) &#x2F;&#x2F;map包裹方法名\n&#x2F;&#x2F; roots is now [1, 2, 3], array is still [1, 4, 9]\n\nvar array &#x3D; [1, 4, 9]\nvar doubles &#x3D; array.map(function (num) &#123;\n  &#x2F;&#x2F;map包裹方法实体\n  return num * 2\n&#125;)\n&#x2F;&#x2F; doubles is now [2, 8, 18]. array is still [1, 4, 9]</code></pre>\n\n<p>实际上,由于 map 方法被设计成支持 [鸭式辨型][] , 该方法也可以用来处理形似数组的对象, 例如 NodeList.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var elems &#x3D; document.querySelectorAll(&#39;select option:checked&#39;)\nvar values &#x3D; Array.prototype.map.call(elems, function (obj) &#123;\n  return obj.value\n&#125;)</code></pre>\n\n<p>甚至还可以用来处理字符串, 如下:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var map &#x3D; Array.prototype.map\nvar array &#x3D; map.call(&#39;Hello 中国&#39;, function (x) &#123;\n  return x.charCodeAt(0)\n&#125;)\nconsole.log(array)\n&#x2F;&#x2F;[72, 101, 108, 108, 111, 32, 20013, 22269]</code></pre>\n\n<p>map 处理字符串的方式多种多样, 例如 反转等.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">var str &#x3D; &#39;12345&#39;\nvar output &#x3D; Array.prototype.map\n  .call(str, function (x) &#123;\n    return x\n  &#125;)\n  .reverse()\n  .join(&#39;&#39;)\nconsole.log(output) &#x2F;&#x2F;54321</code></pre>\n\n<p>例如 将字符串数组转换为数字数组, 只需一条语句, 如下:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">console.log([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(Number)) &#x2F;&#x2F;[1,2,3]</code></pre>\n\n<p>目前 map 方法被大部分浏览器支持, 除了 IE 6,7,8.</p>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h3><p>即 Array.prototype.every, 该方法同上述 map 方法也只支持数组<br>语法: arr.every(callback[, thisArg]) every 方法用于检验数组中的每一项是否符合某个条件, 若符合则放回 true, 反之则返回 false.</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function isBigEnough(element, index, array) &#123;\n  return element &gt;&#x3D; 10\n&#125;\n;[12, 5, 8, 130, 44].every(isBigEnough) &#x2F;&#x2F; false\n;[12, 54, 18, 130, 44].every(isBigEnough) &#x2F;&#x2F; true</code></pre>\n\n<p>该方法还有简写方式, 如下:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">;[12, 5, 8, 130, 44].every((elem) &#x3D;&gt; elem &gt;&#x3D; 10) &#x2F;&#x2F; false\n;[12, 54, 18, 130, 44].every((elem) &#x3D;&gt; elem &gt;&#x3D; 10) &#x2F;&#x2F; true</code></pre>\n\n<p>以上, 遍历数组和对象的 8 种方法简单的介绍完, 小结如下:</p>\n<ul>\n<li>for in , $.each , $().each 既支持对象也支持数组遍历;</li>\n<li>for , do/while , forEach 只支持数组;</li>\n<li>Array.prototype.map, Array.prototype.every 只支持数组和形似数组的对象;</li>\n<li>forEach 不能退出循环,只能通过 return 来进入到下一个元素的遍历中(相当于 for 循环的 continue), 且在 IE 没有实现该方法;</li>\n<li>$.each和$().each 循环只能通过 return false 来退出循环, 使用 return 或 return true 将跳过一个元素, 继续执行后面的循环.</li>\n</ul>\n","text":"遍历数组或对象是一名程序员的基本素养之一，然而遍历却不是一件简单的事，优秀的程序员知道怎么去选择合适的遍历方法，优化遍历效率。本篇将带你走进 JavaScript 遍历的世界，享受分析 JS 循环的快感。本篇所有代码都可以直接运行，希望您通读本篇后，不止是浏览， 最好是亲手去实践...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"JS","slug":"JS","count":4,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":3,"path":"api/tags/JS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#js-%E6%9C%89%E5%A6%82%E4%B8%8B%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%9C%80%E8%A6%81%E7%BB%8F%E5%B8%B8%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">js 有如下两种数据需要经常遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for\"><span class=\"toc-text\">for</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#do-while\"><span class=\"toc-text\">do&#x2F;while</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#forEach\"><span class=\"toc-text\">forEach</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for-in\"><span class=\"toc-text\">for in</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#each\"><span class=\"toc-text\">$.each</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#selecter-each\"><span class=\"toc-text\">$(selecter).each</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#every\"><span class=\"toc-text\">every</span></a></li></ol></li></ol>","author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"理解JS继承方式","uid":"c2607e9298e419e91fd4a6508ed0ae1d","slug":"理解JS继承方式","date":"2019-09-20T14:05:28.000Z","updated":"2021-05-14T10:41:05.732Z","comments":true,"path":"api/articles/理解JS继承方式.json","keywords":null,"cover":"/assets/js2.jpg","text":"1.原型继承模式&#x2F;&#x2F; 父类 function Parent(name, age) &#123; this.name &#x3D; name; this.age &#x3D; age; this.foods &#x3D; [&#39;苹果&#39;，&#39;香...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"JS","slug":"JS","count":4,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":3,"path":"api/tags/JS.json"}],"author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Web Storage - HTML5本地存储","uid":"6c8c7b5d1ee2282dcd4144a2e2072c08","slug":"Web Storage - HTML5本地存储","date":"2019-06-06T02:11:34.000Z","updated":"2021-05-14T10:42:52.639Z","comments":true,"path":"api/articles/Web Storage - HTML5本地存储.json","keywords":null,"cover":"/assets/web-storage.jpg","text":"Web Storage 是 HTML5 引入的一个非常重要的功能，在前端开发中经常用到，可以在客户端本地存储数据，类似 HTML4 的 cookie，但可实现功能要比 cookie 强大的多，cookie 大小被限制在 4KB，Web Storage 官方建议为每个网站 5MB。...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Web Storage","slug":"Web-Storage","count":1,"path":"api/categories/Web-Storage.json"}],"tags":[{"name":"Web Storage","slug":"Web-Storage","count":1,"path":"api/tags/Web-Storage.json"}],"author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}