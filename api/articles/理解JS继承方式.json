{"title":"理解JS继承方式","uid":"c2607e9298e419e91fd4a6508ed0ae1d","slug":"理解JS继承方式","date":"2019-09-20T14:05:28.000Z","updated":"2021-05-14T10:41:05.732Z","comments":true,"path":"api/articles/理解JS继承方式.json","keywords":null,"cover":"/assets/js2.jpg","content":"<h2 id=\"1-原型继承模式\"><a href=\"#1-原型继承模式\" class=\"headerlink\" title=\"1.原型继承模式\"></a>1.原型继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 原型继承方式\nChild.prototype &#x3D; new Parent();\nChild.prototype.constructor &#x3D; Child; &#x2F;&#x2F;因为上面的代码把Child的prototype指向了Parent\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18); &#x2F;&#x2F;希望: 子类继承父类的属性和方法\nvar son2 &#x3D; new Child(&#39;Bob&#39;, 20);\nson1.run();  &#x2F;&#x2F;从Parent原型上继承的方法\nson1.foods.push(&#39;橘子&#39;);\n\nconsole.log(son1.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;, &#39;橘子&#39;]\nconsole.log(son2.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;, &#39;橘子&#39;]\n\n优点：1.简单,易于实现\n\n缺点：1. 子类的构造函数的参数(创建子类实例的参数),没法传递给父类的构造函数\n     2. 子类原型的constructor会被改变，需要自己改回来\n     3. 如果父类有引用类型的属性,那么所有的子类会共享这个引用类型(修改son1.foods后son2.foods也变了，因为来自原型对象的引用属性是所有实例共享的)</code></pre>\n\n<span id=\"more\"></span>\n\n<h2 id=\"2-构造函数继承模式\"><a href=\"#2-构造函数继承模式\" class=\"headerlink\" title=\"2.构造函数继承模式\"></a>2.构造函数继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n  this.fun &#x3D; function() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  &#x2F;&#x2F;使用借用构造函数继承模式来构建对象的实例属性\n  Parent.call(this, name, age); &#x2F;&#x2F;核心\n&#125;\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\n\n核心： 借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）\n\n优点：1. 解决子类实例共享父类引用属性的问题\n     2. 创建子类实例时，可以向父类构造函数传参\n\n缺点：1. 方法都在构造函数中定义, 无法实现函数方法复用，每次创建实例都会创建一遍方法，太多了就会影响性能，占用内存</code></pre>\n\n<h2 id=\"3-组合继承模式\"><a href=\"#3-组合继承模式\" class=\"headerlink\" title=\"3.组合继承模式\"></a>3.组合继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 组合了: 原型继承模式和构造函数继承模式\n\n&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  Parent.call(this, name, age); &#x2F;&#x2F;借用父类的构造函数，给子类创建实例属性\n&#125;\n\n&#x2F;&#x2F; 原型继承方式\nChild.prototype &#x3D; new Parent();\nChild.prototype.constructor &#x3D; Child; &#x2F;&#x2F;因为上面的代码把Child的prototype指向了Parent\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\n\n核心: 把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点，通过Parent.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过Child.prototype &#x3D; new Parent();继承父类函数，实现函数复用\n\n核心: 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式\n\n优点：1. 不存在引用属性共享问题\n     2. 可传参\n     3. 函数可复用\n\n缺点：1. 父类构造函数被调用了两次</code></pre>\n\n<h2 id=\"4-原型式继承模式\"><a href=\"#4-原型式继承模式\" class=\"headerlink\" title=\"4.原型式继承模式\"></a>4.原型式继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 原型式继承的方法，传一个对象，内部新构造一个对象，新对象的原型指向o对象\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\nvar o &#x3D; &#123;name: &#39;Jack, age: 18, foods: [&#39;苹果&#39;，&#39;香蕉&#39;]&#125;;\n\nvar obj &#x3D; createObj(o);\n\nconsole.log(obj.foods); &#x2F;&#x2F; [&#39;苹果&#39;，&#39;香蕉&#39;]\nobj.age &#x3D; 20; &#x2F;&#x2F; 修改属性\n\n优点：1. 不需要使用new构造函数就可以直接构造另外的其他对象\n\n缺点：1. 所有构造出来的实例会共享 原型对象上的引用类型的属性\n\n* ES5通过Object.create()方法规范了原型式继承, 可以接受两个参数，一个是用作新对象原型的对象和一个可选的为新对象定义额外属性的对象，行为相同，基本用法和上面的object一样，除了object不能接受第二个参数以外\n\nvar person &#x3D; &#123;\n  name: ‘Jiang’,\n  friends: [‘Shelby’, ‘Court’]\n&#125;\nvar anotherPerson &#x3D; Object.create(person)\nconsole.log(anotherPerson.friends)  &#x2F;&#x2F; [‘Shelby’, ‘Court’]</code></pre>\n\n<h2 id=\"5-寄生继承模式\"><a href=\"#5-寄生继承模式\" class=\"headerlink\" title=\"5.寄生继承模式\"></a>5.寄生继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 原型式继承的方法，传一个对象，内部新构造一个对象，新对象的原型指向o对象\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\n&#x2F;&#x2F; 寄生继承方式：其实就是传一个对象到一个方法(工厂方法), 方法内部根据传来的对象新构造一个新对象, 并对新对象进行拓展增强, 返回这个新对象\nfunction inheritObj(p) &#123;\n  var o &#x3D; createObj(p); &#x2F;&#x2F; 同p对象构造一个新对象o\n  o.say &#x3D; function() &#123; &#x2F;&#x2F; 对新对象o进行拓展\n    &#x2F;&#x2F;...\n  &#125;\n  return o;\n&#125;</code></pre>\n\n<h2 id=\"6-寄生组合继承模式\"><a href=\"#6-寄生组合继承模式\" class=\"headerlink\" title=\"6.寄生组合继承模式\"></a>6.寄生组合继承模式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 组合了: 寄生继承模式和借用构造函数继承模式\n\n&#x2F;&#x2F; 父类\nfunction Parent(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.foods &#x3D; [&#39;苹果&#39;，&#39;香蕉&#39;];  &#x2F;&#x2F;引用类型的属性\n&#125;\n\n&#x2F;&#x2F; 父类原型上的方法\nParent.prototype.run &#x3D; function() &#123;\n  conosle.log(this.name + &#39; running...&#39;);\n&#125;\n\n&#x2F;&#x2F; 子类\nfunction Child(name, age) &#123;\n  &#x2F;&#x2F;使用借用构造函数继承模式来构建对象的实例属性\n  Parent.call(this, name, age);\n&#125;\n\n&#x2F;&#x2F; 寄生继承的方法\nChild.prototype &#x3D; inheritFrom(Parent.prototype);\n\nvar son1 &#x3D; new Child(&#39;Jack&#39;, 18);\nvar son2 &#x3D; new Child(&#39;Bob&#39;, 20);\nson1.run();\nson2.run();\n\n&#x2F;&#x2F; 寄生继承模式\ninheritFrom(o) &#123;\n  var t &#x3D; createObj(o);\n  t.constructor &#x3D; Child; &#x2F;&#x2F;把Child原型上的构造函数指向Child构造函数\n  return t;\n&#125;\n\n&#x2F;&#x2F; 原型式继承的方法\nfunction createObj(o) &#123;\n  function()&#123;&#125;;\n  F.prototype &#x3D; o;\n  return new F();\n&#125;\n\n或者\n---------------------------\n&#x2F;&#x2F; 寄生继承模式\nfunction prototype(child, parent) &#123;\n    var prototype &#x3D; createObj(parent.prototype);\n    prototype.constructor &#x3D; child;\n    child.prototype &#x3D; prototype;\n&#125;\n\n&#x2F;&#x2F; 当我们使用的时候：\nprototype(Child, Parent);\n</code></pre>\n","text":"1.原型继承模式&#x2F;&#x2F; 父类 function Parent(name, age) &#123; this.name &#x3D; name; this.age &#x3D; age; this.foods &#x3D; [&#39;苹果&#39;，&#39;香...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"JS","slug":"JS","count":4,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":3,"path":"api/tags/JS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.原型继承模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.构造函数继承模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.组合继承模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.原型式继承模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.寄生继承模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.寄生组合继承模式</span></a></li></ol>","author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数组去重总结","uid":"4c337e9614c51b00a241324241640e12","slug":"数组去重总结","date":"2019-10-04T14:05:14.000Z","updated":"2021-05-14T10:48:53.555Z","comments":true,"path":"api/articles/数组去重总结.json","keywords":null,"cover":"/assets/array.jpg","text":"数组去重总结一：利用 ES6 Set 去重 function unique(arr) &#123; return Array.from(new set(arr)) &#125; 二：利用 for 嵌套 for，然后 splice 去重 function unique(arr) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"JS","slug":"JS","count":4,"path":"api/categories/JS.json"}],"tags":[{"name":"array","slug":"array","count":1,"path":"api/tags/array.json"}],"author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"详解JS遍历","uid":"9f17109abe732a77d87a2b0d4189145c","slug":"详解JS遍历","date":"2019-07-20T14:19:44.000Z","updated":"2021-05-14T10:40:31.703Z","comments":true,"path":"api/articles/详解JS遍历.json","keywords":null,"cover":"/assets/js.jpg","text":"遍历数组或对象是一名程序员的基本素养之一，然而遍历却不是一件简单的事，优秀的程序员知道怎么去选择合适的遍历方法，优化遍历效率。本篇将带你走进 JavaScript 遍历的世界，享受分析 JS 循环的快感。本篇所有代码都可以直接运行，希望您通读本篇后，不止是浏览， 最好是亲手去实践...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"JS","slug":"JS","count":4,"path":"api/categories/JS.json"}],"tags":[{"name":"JS","slug":"JS","count":3,"path":"api/tags/JS.json"}],"author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}