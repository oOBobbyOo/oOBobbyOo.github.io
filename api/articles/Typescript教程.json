{"title":"Typescript 教程","uid":"36ed985afabbf28dbf33794d7b5319fd","slug":"Typescript教程","date":"2020-08-26T14:36:20.000Z","updated":"2021-05-14T10:39:55.807Z","comments":true,"path":"api/articles/Typescript教程.json","keywords":null,"cover":"/assets/typescript.jpg","content":"<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。TypeScript 可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码 <a href=\"https://github.com/Microsoft/TypeScript\" title=\"typescript\">开源于 GitHub</a> 上。<br>英文：<a href=\"http://www.typescriptlang.org/\">http://www.typescriptlang.org/</a><br>中文：<a href=\"https://www.tslang.cn/\">https://www.tslang.cn/</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装-TypeScript\"><a href=\"#安装-TypeScript\" class=\"headerlink\" title=\"安装 TypeScript\"></a>安装 TypeScript</h2><p>TypeScript 的命令行工具安装方法如下：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">npm install -g typescript</code></pre>\n\n<p>以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。<br>在命令行上，运行 TypeScript 编译器：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">tsc hello.ts</code></pre>\n\n<p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀。</p>\n<h2 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let isDone: boolean &#x3D; false</code></pre>\n\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let decLiteral: number &#x3D; 6\nlet hexLiteral: number &#x3D; 0xf00d\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744\nlet notANumber: number &#x3D; NaN\nlet infinityNumber: number &#x3D; Infinity</code></pre>\n\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（”）或单引号（’）表示字符串。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let myName: string &#x3D; &#39;Tom&#39;\nlet myAge: number &#x3D; 25\n\n&#x2F;&#x2F; 模板字符串\nlet sentence: string &#x3D; &#96;Hello, my name is $&#123;myName&#125;.\nI&#39;ll be $&#123;myAge + 1&#125; years old next month.&#96;</code></pre>\n\n<p>其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 [ ]，表示由此类型元素组成的一个数组：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let list: number[] &#x3D; [1, 2, 3]</code></pre>\n\n<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let list: Array&lt;number&gt; &#x3D; [1, 2, 3]</code></pre>\n\n<p>用接口表示数组：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface NumberArray &#123;\n  [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5]</code></pre>\n\n<p>NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number。</p>\n<p>用 any 表示数组中允许出现任意类型：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let list: any[] &#x3D; [&#39;Xcat Liu&#39;, 25, &#123; website: &#39;http:&#x2F;&#x2F;xcatliu.com&#39; &#125;]</code></pre>\n\n<h3 id=\"元组-Tuple：\"><a href=\"#元组-Tuple：\" class=\"headerlink\" title=\"元组 Tuple：\"></a>元组 Tuple：</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; Declare a tuple type\nlet x: [string, number]\n&#x2F;&#x2F; Initialize it\nx &#x3D; [&#39;hello&#39;, 10] &#x2F;&#x2F; OK\n&#x2F;&#x2F; Initialize it incorrectly\nx &#x3D; [10, &#39;hello&#39;] &#x2F;&#x2F; Error</code></pre>\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">enum Color &#123;Red, Green, Blue&#125;\nlet c: Color &#x3D; Color.Green;</code></pre>\n\n<p>手动赋值:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">enum Days &#123;Sun &#x3D; 7, Mon &#x3D; 1, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 7); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Mon&quot;] &#x3D;&#x3D;&#x3D; 1); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Tue&quot;] &#x3D;&#x3D;&#x3D; 2); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6); &#x2F;&#x2F; true</code></pre>\n\n<h3 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h3><p>任意值（Any）用来表示允许赋值为任意类型</p>\n<p>在任意值上访问任何属性都是允许的：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let anyThing: any &#x3D; &#39;hello&#39;\nconsole.log(anyThing.myName)\nconsole.log(anyThing.myName.firstName)</code></pre>\n\n<p>也允许调用任何方法：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let anyThing: any &#x3D; &#39;Tom&#39;\nanyThing.setName(&#39;Jerry&#39;)\nanyThing.setName(&#39;Jerry&#39;).sayHello()\nanyThing.myName.setFirstName(&#39;Cat&#39;)</code></pre>\n\n<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p>\n<h3 id=\"Void\"><a href=\"#Void\" class=\"headerlink\" title=\"Void\"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function warnUser(): void &#123;\n  alert(&#39;This is my warning message&#39;)\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let unusable: void &#x3D; undefined</code></pre>\n\n<h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p>TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let u: undefined &#x3D; undefined\nlet n: null &#x3D; null</code></pre>\n\n<p>undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。<br>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined\n\n&#x2F;&#x2F; 这样也不会报错\nlet u: undefined\nlet num: number &#x3D; u\n\n&#x2F;&#x2F; 而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void\nlet num: number &#x3D; u\n\n&#x2F;&#x2F; index.ts(2,5): error TS2322: Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。</p>\n<p>使用接口（Interfaces）来定义对象的类型:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Person &#123;\n  name: string;\n  age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  age: 25,\n&#125;</code></pre>\n\n<p>赋值的时候，变量的形状必须和接口的形状保持一致。</p>\n<p>可选属性，有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Person &#123;\n  name: string;\n  age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n&#125;</code></pre>\n\n<p>可选属性的含义是该属性可以不存在,仍然不允许添加未定义的属性：</p>\n<p>任意属性, 有时候我们希望一个接口允许有任意的属性:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Person &#123;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  gender: &#39;male&#39;,\n&#125;</code></pre>\n\n<p>使用 [propName: string] 定义了任意属性取 string 类型的值。<br>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Person &#123;\n  name: string;\n  age?: number;\n  [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n  name: &#39;Tom&#39;,\n  age: 25,\n  gender: &#39;male&#39;,\n&#125;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。<br>另外，在报错信息中可以看出，此时 { name: ‘Tom’, age: 25, gender: ‘male’ } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。</p>\n<p>只读属性, 有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>传统的 JavaScript 程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>\n<p>使用类的例子:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Greeter &#123;\n  greeting: string\n  constructor(message: string) &#123;\n    this.greeting &#x3D; message\n  &#125;\n  greet() &#123;\n    return &#39;Hello, &#39; + this.greeting\n  &#125;\n&#125;\n\nlet greeter &#x3D; new Greeter(&#39;world&#39;)</code></pre>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。<br>类继承类：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Animal &#123;\n  move(distanceInMeters: number &#x3D; 0) &#123;\n    console.log(&#96;Animal moved $&#123;distanceInMeters&#125;m.&#96;)\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  bark() &#123;\n    console.log(&#39;Woof! Woof!&#39;)\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog()\ndog.bark()\ndog.move(10)\ndog.bark()</code></pre>\n\n<p>接口继承接口：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">interface Alarm &#123;\n    alert();\n&#125;\n\ninterface LightableAlarm extends Alarm &#123;\n    lightOn();\n    lightOff();\n&#125;</code></pre>\n\n<p>上例中，我们使用 extends 使 LightableAlarm 继承 Alarm。</p>\n<p>接口继承类：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Point &#123;\n  x: number\n  y: number\n&#125;\n\ninterface Point3d extends Point &#123;\n  z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123; x: 1, y: 2, z: 3 &#125;</code></pre>\n\n<h3 id=\"公共，私有与受保护的修饰符\"><a href=\"#公共，私有与受保护的修饰符\" class=\"headerlink\" title=\"公共，私有与受保护的修饰符\"></a>公共，私有与受保护的修饰符</h3><p>默认为公共方法 public：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Animal &#123;\n    public name: string;\n    public constructor(theName: string) &#123;\n    \tthis.name &#x3D; theName;\n    &#125;\n    public move(distanceInMeters: number) &#123;\n        console.log(&#96;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#96;);\n    &#125;\n&#125;</code></pre>\n\n<p>静态方法 static:<br>使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Animal &#123;\n  static isAnimal(a) &#123;\n    return a instanceof Animal\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;)\nAnimal.isAnimal(a) &#x2F;&#x2F; true\na.isAnimal(a) &#x2F;&#x2F; TypeError: a.isAnimal is not a function</code></pre>\n\n<p>私有方法 private：<br>当成员被标记成 private 时，它就不能在声明它的类的外部访问。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Animal &#123;\n    private name: string;\n    constructor(theName: string) &#123;\n    \tthis.name &#x3D; theName;\n   \t&#125;\n&#125;\nnew Animal(&quot;Cat&quot;).name; &#x2F;&#x2F; 错误: &#39;name&#39; 是私有的</code></pre>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">class Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n  get name() &#123;\n    return &#39;Jack&#39;\n  &#125;\n  set name(value) &#123;\n    console.log(&#39;setter: &#39; + value)\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Kitty&#39;) &#x2F;&#x2F; setter: Kitty\na.name &#x3D; &#39;Tom&#39; &#x2F;&#x2F; setter: Tom\nconsole.log(a.name) &#x2F;&#x2F; Jack</code></pre>\n\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>导出, 任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加 export 关键字来导出:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">export interface StringValidator &#123;\n  isAcceptable(s: string): boolean;\n&#125;</code></pre>\n\n<p>导入,模块的导入操作与导出一样简单。 可以使用以下 import 形式之一来导入其它模块中的导出内容。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">import &#123; ZipCodeValidator &#125; from &#39;.&#x2F;ZipCodeValidator&#39;\n\nlet myValidator &#x3D; new ZipCodeValidator()</code></pre>\n\n<p>可以对导入内容重命名</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">import &#123; ZipCodeValidator as ZCV &#125; from &#39;.&#x2F;ZipCodeValidator&#39;\nlet myValidator &#x3D; new ZCV()</code></pre>\n\n<p>将整个模块导入到一个变量，并通过它来访问模块的导出部分</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">import * as validator from &#39;.&#x2F;ZipCodeValidator&#39;\nlet myValidator &#x3D; new validator.ZipCodeValidator()</code></pre>\n\n<p>默认导出,每个模块都可以有一个 default 导出。 默认导出使用 default 关键字标记；并且一个模块只能够有一个 default 导出。 需要使用一种特殊的导入形式来导入 default 导出。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">export default class ZipCodeValidator &#123;\n    static numberRegexp &#x3D; &#x2F;^[0-9]+$&#x2F;;\n    isAcceptable(s: string) &#123;\n        return s.length &#x3D;&#x3D;&#x3D; 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);\n    &#125;\n&#125;\n-------------------------------------------------------------------------\nimport validator from &quot;.&#x2F;ZipCodeValidator&quot;;\nlet myValidator &#x3D; new validator();</code></pre>\n\n<p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://ts.xcatliu.com/\">TypeScript 入门教程</a><br><a href=\"https://www.tslang.cn/docs/handbook/basic-types.html\">TypeScript 官方手册</a></p>\n","feature":true,"text":"TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。TypeScript 可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码 开源于 GitH...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Typescript","slug":"Typescript","count":1,"path":"api/categories/Typescript.json"}],"tags":[{"name":"Typescript","slug":"Typescript","count":1,"path":"api/tags/Typescript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-TypeScript\"><span class=\"toc-text\">安装 TypeScript</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基础类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%83%E5%B0%94%E5%80%BC\"><span class=\"toc-text\">布尔值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">数字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84-Tuple%EF%BC%9A\"><span class=\"toc-text\">元组 Tuple：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Any\"><span class=\"toc-text\">Any</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Void\"><span class=\"toc-text\">Void</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Null-%E5%92%8C-Undefined\"><span class=\"toc-text\">Null 和 Undefined</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%85%B1%EF%BC%8C%E7%A7%81%E6%9C%89%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">公共，私有与受保护的修饰符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%8F%96%E5%99%A8\"><span class=\"toc-text\">存取器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol>","author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"vue.config.js 配置","uid":"bbe4af776c0ccb3326bd13f893d1dc57","slug":"Vue.config.js配置","date":"2020-07-15T12:19:10.000Z","updated":"2021-05-14T10:40:09.382Z","comments":true,"path":"api/articles/Vue.config.js配置.json","keywords":null,"cover":"assets/vue.png","text":"vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。 配置参考 &#x2F;&#x2F; vue.config.js const path &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"Vue","slug":"Vue","count":1,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":1,"path":"api/tags/Vue.json"}],"author":{"name":"Bobby's Blog","slug":"blog-author","avatar":"/assets/user/bobby.jpg","link":"/","description":"欢迎来到我的博客 <br /> (σﾟ∀ﾟ)σ..:*☆哎哟不错哦","socials":{"github":"https://github.com/oOBobbyOo","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}